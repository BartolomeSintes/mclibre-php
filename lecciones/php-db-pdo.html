<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>PHP Data Objects (PDO). PHP. Bartolomé Sintes Marco. www.mclibre.org</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../varios/php.css" title="mclibre">
  <link rel="icon" href="../varios/favicon.svg">
  <link rel="stylesheet" href="../varios/prism.css">
  <script src="../varios/prism.js"></script>
</head>

<body>
  <h1>PHP Data Objects (PDO)</h1>

  <nav>
    <p>
      <a href="../index.html"><img src="../varios/iconos/icono-php.svg" alt="Índice de PHP" title="Índice de PHP" width="48" height="48"></a>
      <a href="#"><img src="../varios/iconos/icono-arrow-circle-up.svg" alt="Principio de la página" title="Principio de la página" width="36" height="36"></a>
    </p>

    <div class="toc">
      <h2>PHP Data Objects (PDO)</h2>

      <ul>
        <li><a href="#conceptos-basicos">Conceptos básicos</a></li>
        <li><a href="#seguridad">Consultas preparadas</a></li>
        <li><a href="#ejemplos-codigo">Ejemplos SQLite / MySQL</a>
          <ul>
            <li><a href="#opciones">Opciones del programa</a></li>
            <li><a href="#conexion">Conexión</a></li>
            <li><a href="#create-drop">CREATE, DROP</a></li>
            <li><a href="#insert-update-delete">INSERT, UPDATE, DELETE</a></li>
            <li><a href="#select">SELECT</a></li>
            <li><a href="#select-like">SELECT LIKE</a></li>
            <li><a href="#union-tablas">unión de tablas</a></li>
          </ul>
        </li>
        <li><a href="#configurable">Aplicación configurable</a>
          <ul>
            <li><a href="#conexion-configurable">Conexión configurable</a></li>
            <li><a href="#create-drop-configurable">CREATE configurable</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </nav>

  <p>La extensión <a href="https://www.php.net/manual/en/book.pdo.php">PDO (PHP Data Objects)</a> permite acceder a distintas bases de datos (MySQL/MariaBD, PostgreSQL, Oracle, MS SQL Server, SQLite, Firebird, DB2, Informix, etc.) de una forma uniforme, lo que facilita la portabilidad de las aplicaciones. La portabilidad entre bases de datos no es absoluta debido por ejemplo a las diferencias entre diferentes bases de datos en aspectos como la forma de conectarse o la sintaxis del lenguaje de definición de datos. Para ilustrar esas diferencias y como tratarlas adecuadamente, se ofrecen ejemplos de código específicos para SQLite y para MySQL.</p>

  <p>La extensión PDO no evalúa la corrección de las consultas SQL, aunque sí implementa algunas medidas de seguridad mediante consultas preparadas, como se comenta en el apartado correspondiente.</p>

  <section id="conceptos-basicos">
    <h2>Conceptos básicos de PDO</h2>

    <p>PDO es una biblioteca de PHP orientada a objetos, pero se puede utilizar sin problemas en un programa no orientado a objetos. Tan solo será necesario utilizar la notación propia de la orientación orientada a objetos al manipular el objeto PDO.</p>

    <section id="basicos-conexion">
      <h3>Conexión con la base de datos</h3>

      <p>Para trabajar con una base de datos en nuestro programa, simplemente nos conectaremos con la base de datos creando un objeto PDO. La información necesaria para la conexión con la base de datos específica se incluye como uno o varios argumentos:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// CONEXIÓN CON LA BASE DE DATOS

$pdo = new PDO("<i>informacion-para-la-conexion</i>");</code>
</pre>
      </div>

      <p>La información para la conexión consiste en primer lugar en el DSN (<a href="https://en.wikipedia.org/wiki/Data_source_name">Data Source Name</a>), que indica como mínimo el nombre de la base de datos (sqlite, mysql, pgsql, etc.) y su ubicación. En su caso, el segundo y tercer argumento son el nombre y contraseña del usuario de la base de datos.</p>

      <p>Si por algún motivo PDO no puede conectarse con la base de datos, se genera una excepción. En los ejemplos y soluciones de ejercicios de estos apuntes cuando se produce esta excepción se muestra un mensaje en español y a continuación el código de error SQLSTATE y el mensaje de error específico del driver.</p>

      <div class="codigo">
        <pre>
<code class="language-php">        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos. {$e-&gt;getMessage()}&lt;/p&gt;\n";</code>
</pre>
      </div>
    </section>

    <section id="basicos-errores">
      <h3>Manejo de errores de PDO</h3>

      <p>PDO permite elegir al usuario entre tres formas distintas de <a href="https://www.php.net/manual/en/pdo.error-handling.php">gestionar los errores encontrado</a> al realizar las consultas (normalmente por errores de sintaxis de SQL):</p>
      <ul>
        <li>PDO::ERRMODE_SILENT
          <p>En este modo, los errores de PDO no interrumpen la ejecución del programa, simplemente se guardan y se pueden consultar mediante los métodos <a href="https://www.php.net/manual/en/pdo.errorcode.php">errorCode()</a> y <a href="https://www.php.net/manual/en/pdo.errorinfo.php">errorInfo</a>. Si utilizamos este modo, nuestro programa tiene que encargarse de comprobar tras cada consulta si ha habido un error y tenerlo en cuenta.</p>
        </li>
        <li>PDO::ERRMODE_WARNING
          <p>En este modo, PDO además de guardar los errores genera un aviso de tipo E_WARNING que, dependiendo de la <a href="../otros/php-configuracion-1.html#error-reporting">configuración de error_reporting</a>, se mostrará o no en pantalla.</p>
        </li>
        <li>PDO::ERRMODE_EXCEPTION
          <p>En este modo, PDO genera una excepción de clase <a href="https://www.php.net/manual/en/class.pdoexception.php">PDOException</a>. Si utilizamos este modo, nuestro programa tiene que gestionar las excepciones, porque si no el programa se interrumpe con un error E_ERROR.</p>
        </li>
      </ul>

      <p>Hasta PHP 8.0, publicado en 2020, el modo predeterminado era ERRMODE_SILENT, pero desde esa versión es ERRMODE_EXCEPTION. En estos apuntes se utiliza el modo PDO::ERRMODE_SILENT, que se puede abordar con simples estructuras if .. else ..., mientras que el modo PDO::ERRMODE_EXCEPTION requiere estructuras try ... catch ... que no se tratan actualmente en estos apuntes.</p>

      <p>El modo de manejo de errores se selecciona activando el atributo PDO::ATTR_ERRMODE tras conectarse con la base de datos, como se comenta más adelante en esta lección en el apartado dedicado a la conexión con la base de datos:</p>
      <div class="codigo">
        <pre>
<code class="language-php">      $tmp-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);</code>
</pre>
      </div>
    </section>

    <section id="basicos-ejecucion">
      <h3>Ejecución de las consultas</h3>

      <p>Una vez realizada la conexión, las consultas SQL se realizar a través del objeto PDO. La ejecución de la consulta y el tratamiento de la respuesta se puede hacer de cuatro formas distintas, atendiendo a dos criterios:</p>

      <p>Por un lado, se debe considerar si la consulta incluye información que nos ha llegado a través de un formulario. Por otro lado, se debe considerar si la consulta puede devolver registros:</p>
      <ul>
        <li>Si la consulta <strong>no</strong> incluye datos provinientes de un formulario, se puede utilizar el método <a href="https://www.php.net/manual/en/pdo.query.php"><span class="php-fun">PDO-&gt;query(<i>consulta</i>)</span></a>:
          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA SIN DATOS PROVENIENTES DE UN FORMULARIO

$pdo-&gt;query("<i>consulta</i>");</code>
</pre>
          </div>

          <ul>
            <li>Si por el tipo de consulta de que se trata sabemos que la consulta <strong>no</strong> va a devolver registros, la consulta devolverá simplemente <span class="php-con">true</span> (si la consulta se realiza con éxito) o <span class="php-con">false</span> (si la consulta falla). En ese caso podemos utilizar directamente el resultado de la consulta en una estructura <span class="php-res">if ... else ...</span> para gestionar las tareas a realizar en cada caso. Conviene escribir la condición en negativo (con exclamación delante), para escribir en primer lugar el caso en el que la consulta falle, que normalmente contendrá menos líneas de programa:
              <div class="codigo">
                <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA QUE NO VA A DEVOLVER REGISTROS

if (!$pdo-&gt;query("<i>consulta</i>")) {
    ...    // Si la consulta falla
} else {
    ...    // Si la consulta se ejecuta correctamente
}</code>
</pre>
              </div>
            </li>
            <li>Si la consulta puede devolver registros, devolverá <span class="php-con">false</span> (si la consulta falla) o cero, uno o varios registros. En ese caso conviene guardar el resultado de la consulta en una variable auxiliar y escribir la estructura <span class="php-res">if ... else ...</span> a partir de esa variable auxiliar:

              <div class="codigo">
                <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA QUE PUEDE DEVOLVER REGISTROS

$resultado = $pdo-&gt;query("<i>consulta</i>")
if (!$resultado) {
    ...    // Si la consulta falla
} else {
    ...    // Si la consulta se ejecuta correctamente
}</code>
</pre>
              </div>
            </li>
          </ul>
        </li>

        <li>Si la consulta <strong>sí</strong> incluye datos provinientes de un formulario, se deben utilizar consultas preparadas para evitar ataques de inyección SQL de los que el método query() no nos protege. El método para efectuar consultas es primero preparar la consulta con <a href="https://www.php.net/manual/en/pdo.prepare.php"><span class="php-fun">PDO-&gt;prepare(<i>consulta</i>)</span></a> y después ejecutarla con <span class="php-fun"><a href="https://www.php.net/manual/en/pdostatement.execute.php">PDO-&gt;execute(<i>[parámetros]</i>)</a></span>, que devuelve el resultado de la consulta.
          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA CON DATOS PROVENIENTES DE UN FORMULARIO

$resultado = $pdo-&gt;prepare("<i>consulta</i>");
$resultado-&gt;execute([<i>parámetros de la consulta</i>]);</code>
</pre>
          </div>

          <p>En este caso, independientemente de que la consulta devuelva a o no registros, debemos utilizar siempre una variable auxiliar y escribir la estructura <span class="php-res">if ... else ...</span> a partir de esa variable auxiliar, puesto que debemos comprobar si ha fallado tanto la preparación de la consulta como la ejecución de la sentencia preparada:</p>

          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA PREPARADA

$resultado = $pdo-&gt;prepare("<i>consulta</i>")
if (!$resultado) {
    ...        // Si la preparación de la consulta falla
} elseif (!$resultado-&gt;execute([<i>parámetros de la consulta</i>]) {
    ...        // Si la ejecución de la consulta falla
} else {
    ...        // Si la consulta se ejecuta correctamente
}</code>
</pre>
          </div>
        </li>
      </ul>

      <hr class="corta">

      <p>Cuando la consulta falle, es conveniente mostrar al usuario el motivo del fallo. Para ello, podemos utilizar los métodos <a href="https://www.php.net/manual/en/pdo.errorcode.php">errorCode()</a> y <a href="https://www.php.net/manual/en/pdo.errorinfo.php">errorInfo()</a>. errorCode() devuelve el código de error <a href="https://en.wikipedia.org/wiki/SQLSTATE" title="SQLSTATE en Wikipedia">SQLSTATE</a> definido en la norma ANSI SQL. errorInfo() devuelve una matriz con el código de error SQLSTATE, el código de error específico del driver y el mensaje de error específico del driver.</p>

      <p>En los ejemplos y soluciones de ejercicios de estos apuntes cuando se produce un error se muestra un mensaje en español y a continuación el código de error SQLSTATE y el mensaje de error específico del driver.</p>

      <div class="codigo">
        <pre>
<code class="language-php">    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";</code>
</pre>
      </div>

      <hr class="corta">

      <p>En los ejemplos anteriores se ha escrito la consulta en la llamada al método, pero es habitual definir una variable $consulta que contenga la consulta y utilizar esa variable en la llamada al método:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// En una sola línea de programa

$resultado = $pdo-&gt;query("SELECT * FROM <i>tabla</i>");

// En dos líneas de programa

$consulta  = "SELECT * FROM <i>tabla</i>";
$resultado = $pdo-&gt;query($consulta);</code>
</pre>
      </div>

      <p>Utilizar una variable auxiliar permite por ejemplo imprimir la consulta mientras se está programando para comprobar que no tiene errores.</p>

      <div class="codigo">
        <pre>
<code class="language-php">$consulta = "SELECT * FROM <i>tabla</i>";
print "&lt;p&gt;Consulta: $consulta&lt;/p&gt;\n";
// var_dump($consulta);
$resultado  = $pdo-&gt;query($consulta);</code>
</pre>
      </div>
    </section>

    <section id="basicos-resultado">
      <h3>Gestión de los registros devueltos por la consulta</h3>

      <p>Cuando la consulta puede devolver registros, se debe guardar la respuesta en una variable auxiliar. Esa variable es de un tipo especial llamado <a href="https://www.php.net/manual/en/language.types.resource.php">recurso</a> que no se puede acceder directamente, pero de la que podemos ir extrayendo uno a uno los registros mediante un bucle <span class="php-res">foreach ()</span> o mediante los métodos fetch() o fetchColumn():</p>

      <ul>
        <li>Si la consulta devuelve un único registro que contiene la respuesta buscada en la primera columna, se puede utilizar el método <a href="https://www.php.net/manual/en/pdostatement.fetchcolumn.php">PDOStatement-&gt;fetchColumn()</a> para recuperar la primera columna del registro.

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA

$consulta  = "SELECT COUNT(*) FROM <i>tabla</i>";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;La tabla contiene {<span class="codigo-resaltado">$resultado-&gt;fetchColumn()</span>} registro(s).&lt;/p&gt;\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve un único registro, se puede utilizar el método <a href="https://www.php.net/manual/en/pdostatement.fetch.php">PDOStatement-&gt;fetch()</a> para recuperar el registro en forma de matriz. De forma predeterminada, los valores del registro aparecen repetidos en la matriz y para acceder a los valores se puede utilizar como índice tanto los nombres de las columnas de la tabla como números enteros correlativos (0, 1, 2, etc.). Si se enviara como argumento la constante PDO::FETCH_ASSOC, los índices de la matriz serían únicamente los nombres de las columnas de la tabla.

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO (O NINGUNO)

$id = <i>id</i>;          // Normalmente este valor vendrá de un formulario

$consulta  = "SELECT * FROM <i>tabla</i> WHERE <i>id</i>=<i>:id</i>";   // Normalmente solo habrá un registro (o ninguno) con un id determinado

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute(["<i>:id</i>" =&gt; $id])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    $registro = <span class="codigo-resaltado">$resultado-&gt;fetch()</span>;
    print "    &lt;p&gt;&lt;strong&gt;Registro obtenido&lt;/strong&gt;&lt;/p&gt;\n";
    print "\n";
    print "    &lt;p&gt;$registro[<i>columna1</i>] - $registro[<i>columna2</i>] - etc.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve varios registros y simplemente queremos acceder a los registros de forma consecutiva, podemos recorrer la variable que guarda la respuesta con un bucle <span class="php-res">foreach ()</span>. En este caso, si la consulta no devuelve ningún registro no se escribiría ningún mensaje específico, simplemente no se escribiría nada:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta  = "SELECT * FROM <i>tabla</i>";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
    print "    &lt;ul&gt;\n";
    <span class="codigo-resaltado">foreach ($resultado as $registro)</span> {
        print "      &lt;li&gt;$registro[<i>columna1</i>] - $registro[<i>columna2</i>] - etc.&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve varios registros y necesitamos acceder a todos los registros a la vez para realizar alguna operación (como por ejemplo comprobar si no se ha recibido ningún registro), se puede utilizar el método <a href="https://www.php.net/manual/en/pdostatement.fetchall.php">PDOStatement-&gt;fetchAll()</a> para recuperar todos los registros en forma de matriz bidimensional.

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta = "SELECT * FROM <i>tabla</i>";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!count($registros = <span class="codigo-resaltado">$resultado-&gt;fetchAll()</span>)) {
    print "    &lt;p class=\"aviso\"&gt;No se ha creado todavía ningún registro.&lt;/p&gt;\n";
} else
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
    print "    &lt;ul&gt;\n";
    <span class="codigo-resaltado">foreach ($registros as $registro)</span> {
        print "      &lt;li&gt;$registro[<i>columna1</i>] - $registro[<i>columna2</i>] - etc.&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="basicos-desconexion">
      <h3>Desconexión con la base de datos</h3>

      <p>Para desconectar con la base de datos, simplemente hay que destruir el objeto PDO.</p>

      <div class="codigo">
        <pre><code class="language-php">$pdo = null;</code></pre>
      </div>

      <p>Aunque no se destruya el objeto PDO, PHP lo destruye al terminar la página, por lo que a menudo la instrucción no se suele escribir.</p>
    </section>
  </section>

  <section id="seguridad">
    <h2>Consultas preparadas: seguridad en las consultas</h2>

    <p>Para evitar ataques de inyección SQL (en la lección <a href="php-db-inyeccion-sql.html">Inyecciones SQL</a> se comentan los ataques más elementales), se recomienda el uso de <a href="https://www.php.net/manual/en/pdo.prepared-statements.php">sentencias preparadas</a>, en las que PDO se encarga de "desinfectar" los datos. En general, cualquier consulta que incluya datos provenientes de un formulario (o en general, provenientes del usuario de la aplicación) debe realizarse mediante consultas preparadas.</p>

    <section id="consultas-preparadas">
      <h3>Consultas preparadas</h3>

      <p>El método para efectuar consultas preparadas es primero preparar la consulta con <a href="https://www.php.net/manual/en/pdo.prepare.php"><span class="php-fun">PDO-&gt;prepare($consulta)</span></a> y después ejecutarla con <span class="php-fun"><a href="https://www.php.net/manual/en/pdostatement.execute.php">PDO-&gt;execute([parámetros])</a></span>, que devuelve el resultado de la consulta.</p>

      <div class="codigo">
        <pre>
<code class="language-php">// Consulta preparada

$consulta  = "SELECT * FROM <i>tabla</i>";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;execute();</code>
</pre>
      </div>

      <p>Si el programa incluye directamente en la consulta los datos recibidos a través de un formulario, PDO no puede hacer ninguna "desinfección" de los datos, ya que PDO no puede identificar qué parte de la consulta es la que ha llegado de un formulario y que puede haber manipulado la consulta original:</p>

      <div class="filaflex">
        <div class="icono-ok">
          <img src="../varios/iconos/icono-oksemi.svg" alt="Desaconsejado" title="Desaconsejado" width="40" height="40">
        </div>
        <div class="codigo">
          <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// ¡CUIDADO! DESACONSEJADO: PDO NO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=<i>$valor1</i></span>
             AND <span class="codigo-resaltado">columna2=<i>$valor2</i></span>";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute();) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>
      </div>

      <p>Para que PDO pueda desinfectar los datos provinientes de un formulario, estos deben enviarse al ejecutar la consulta, no al prepararla. Para ello, al definir la consulta es necesario indicar la posición de los datos y al ejecutar la consulta es necesario indicar el valor de los datos en forma de matriz. La posición de los datos se puede indicar de dos maneras distintas, mediante parámetros o mediante interrogantes (se aconseja la utilización de parámetros para evitar errores). </p>
      <ul>
        <li>consulta preparada mediante parámetros (:parametro)
          <p>En este caso las posiciones en la que se insertarán los datos provenientes del formulario se indican mediante cadenas de texto precedidas de dos puntos (:). La matriz con los datos debe incluir los nombres de los parámetros y los valores que sustituyen a los parámetros (el orden no es importante), como muestra el siguiente ejemplo:</p>

          <div class="filaflex">
            <div class="icono-ok">
              <img src="../varios/iconos/icono-oksi.svg" alt="Correcto" title="Correcto" width="40" height="40">
            </div>
            <div class="codigo">
              <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// CONSULTA PREPARADA CON PARÁMETROS: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=<i>:valor1</i></span>
             AND <span class="codigo-resaltado">columna2=<i>:valor2</i></span>";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;<span class="codigo-resaltado">execute([":valor1" =&gt; $valor1, ":valor2" =&gt; $valor2])</span>;) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
            </div>
          </div>
        </li>
        <li>consulta preparada mediantes interrogantes (?)
          <p>En este caso las posiciones en la que se insertarán los datos provenientes del formulario se indican mediante interrogantes (?). La matriz con los datos debe incluir los valores que sustituyen a los interrogantes (en el mismo orden en que aparecen en la consulta), como muestra el siguiente ejemplo:</p>

          <div class="filaflex">
            <div class="icono-ok">
              <img src="../varios/iconos/icono-oksi.svg" alt="Correcto" title="Correcto" width="40" height="40">
            </div>
            <div class="codigo">
              <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// CONSULTA PREPARADA CON INTERROGANTES: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=?</span>
             AND <span class="codigo-resaltado">columna2=?</span>";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;<span class="codigo-resaltado">execute([$valor1, $valor2])</span>;) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
            </div>
          </div>
        </li>
      </ul>

      <p><strong>Notas</strong>:</p>
      <ul>
        <li>Aunque no vayan a causar problemas en las consultas, sigue siendo conveniente tratar los datos recibidos para eliminar los espacios en blanco iniciales y finales, tratar los caracteres especiales del html, etc., como se comenta en la <a href="php-recogida-datos.html">lección de Recogida de datos</a>.</li>
        <li>La sintaxis mediante interrogantes es más cómoda, pero tiene el inconveniente de que podemos equivocarnos en el orden de los parámetros. Sin embargo con la sintaxis mediante parámetros, aunque sea más larga de escribir, no se puede cometer ese error.</li>
      </ul>
    </section>

    <section id="restricciones">
      <h3>Restricciones en los parámetros de consultas preparadas</h3>

      <p>Debido a que las consultas preparadas se idearon para optimizar el rendimiento de las consultas, el uso de parámetros tiene algunas restricciones. Por ejemplo</p>
      <ul>
        <li>los identificadores (nombres de tablas, nombres de columnas, etc) no pueden sustituirse por parámetros</li>
        <li>los dos elementos de una igualdad no pueden sustituirse por parámetros</li>
        <li>en general no pueden utilizarse parámetros en las consultas DDL (lenguaje de definición de datos) (nombre y tamaño de las columnas, etc.)</li>
      </ul>

      <p>Si no podemos usar parámetros, no queda más remedio que incluir los datos en la consulta. Como en ese caso PHP no hace ninguna desinfección de los datos, la desinfección la tenemos que hacer nosotros previamente.</p>

      <p>Como en estos casos los valores introducidos por el usuario suelen tener unos valores restringidos (por ejemplo, si el usuario puede elegir una columna de una tabla, los nombres de las columnas están determinadas y el usuario sólo puede elegir uno de ellos), podemos crear una función de recogida de datos específica que impida los ataques de inyección por parte del usuario, como muestra el siguiente ejemplo:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// FUNCIÓN DE RECOGIDA DE UN DATO QUE SÓLO PUEDE TOMAR DETERMINADOS VALORES

function recogeValores($var, $valoresValidos, $valorPredeterminado)
{
    if (isset($_REQUEST[$var]) && in_array($_REQUEST[$nombre], $valoresValidos)) {
        return $_REQUEST[$var];
    } else {
        return $valorPredeterminado;
    }
}

// EJEMPLO DE USO DE LA FUNCIÓN ANTERIOR

// Matriz con los nombres válidos de las columnas de la tabla
$columnas = [
    "columna1",
    "columna2",
    ...
];

$columna = recogeValores("columna", $columnas, "columna1");
$valor1  = $_REQUEST["valor1"];

// CONSULTA PREPARADA CON PARÁMETROS: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT * FROM <i>tabla</i>
             WHERE columna1=<span class="codigo-resaltado"><i>:valor1</i></span>
             ORDER BY <span class="codigo-resaltado">$columna</span> ASC";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;<span class="codigo-resaltado">execute([":valor1" =&gt; $valor1])</span>;) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    ...</code>
</pre>
      </div>
    </section>
  </section>

  <section id="ejemplos-codigo">
    <h2>Ejemplos de código para SQLite y MySQL</h2>

    <p>A continuación se ofrecen ejemplos de código de cómo se podría trabajar con PDO para realizar las tareas más habituales de gestión de una base de datos.</p>

    <p>La base de datos de estos ejemplos tiene una estructura muy simple: una sola tabla <i>personas</i> con tres columnas: un identificador numérico (<i>id</i>), el nombre y los apellidos de una persona.</p>

    <p>La estructura general de estas consultas se repite con ligeras variaciones. La estructura concreta viene impuesta por dos aspectos:</p>
    <ul>
      <li>Si el resultado de la consulta va a ser únicamente <span class="php-con">true</span> o <span class="php-con">false</span>, o si el resultado pueden ser uno o varios registros con una o varias columnas de datos. Si se pueden obtener registros, el resultado de la consulta debe guardarse en una variable auxiliar.</li>
      <li>Si en la consulta deben incluirse datos recibidos de un formulario o no. Si se incluyen datos recibidos de un formulario, es necesario utilizar consultas preparadas para prevenir ataques de inyección SQL. Si se utiliza una consulta preparada, el resultado de la preparación debe guardarse en una variable auxiliar.</li>
    </ul>

    <section id="opciones">
      <h3>Opciones del programa</h3>

      <p>Para dotar de flexibilidad a la aplicación, la aplicación incluirá opciones de configuración en forma de variables. Distinguiremos entre opciones disponibles para el administrador de la aplicación y opciones disponibles para el programador. Aunque la distinción es a veces algo arbitraria, el objetivo es ayudar al administrador de la aplicación en su puesta en marcha:</p>
      <ul>
        <li>Las opciones de administrador son las opciones que el administrador debe establecer al instalar el programa y las opciones que el programador pone a disposición del administrador para que personalice la aplicación.</li>
        <li>Las opciones de programador son las opciones que el administrador no necesita modificar para instalar el programa, pero que el programador ha preparado para dar mayor flexibilidad a la aplicación. Por supuesto, el administrador puede modificarlas si entiende las consecuencias que podría provocar su modificación.</li>
      </ul>

      <p>Estas podrían ser las opciones para <strong>SQLite</strong>:</p>

      <div class="codigo copy">
        <pre>
<code class="language-php">// SQLITE: OPCIONES DE CONFIGURACIÓN DEL PROGRAMA

// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN

// Configuración para SQLite

$cfg["sqliteDatabase"] = "/tmp/db.sqlite";                        // Ubicación de la base de datos

// Configuración de la tabla Personas

$cfg["tablaPersonasTamNombre"]    = 40;                           // Tamaño de la columna Personas &gt; Nombre
$cfg["tablaPersonasTamApellidos"] = 60;                           // Tamaño de la columna Personas &gt; Apellidos

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN

// Base de datos

$cfg["tablaPersonas"] = "personas";                               // Nombre de la tabla Personas</code>
</pre>
      </div>

      <p>Estas podrían ser las opciones para <strong>MySQL</strong>:</p>

      <div class="codigo copy">
        <pre>
<code class="language-php">// MYSQL: OPCIONES DE CONFIGURACIÓN DEL PROGRAMA

// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN

// Configuración para MySQL

$cfg["mysqlHost"]     = "localhost";                              // Nombre de host
$cfg["mysqlUser"]     = "";                                       // Nombre de usuario
$cfg["mysqlPassword"] = "";                                       // Contraseña de usuario
$cfg["mysqlDatabase"] = "";                                       // Nombre de la base de datos

// Configuración de la tabla Personas

$cfg["tablaPersonasTamNombre"]    = 40;                           // Tamaño de la columna Personas &gt; Nombre
$cfg["tablaPersonasTamApellidos"] = 60;                           // Tamaño de la columna Personas &gt; Apellidos

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN

// Base de datos

$cfg["tablaPersonas"] = "$cfg[mysqlDatabase].personas";           // Nombre de la tabla Personas</code>
</pre>
      </div>
    </section>

    <section id="conexion">
      <h3>Conexión con la base de datos</h3>

      <p>Para conectar con la base de datos hay que crear una instancia de la clase PDO, que se utiliza en todas las consultas posteriores. En cada página php que incluya consultas a la base de datos es necesario conectar primero con la base de datos.</p>

      <p>Si no se puede establecer la conexión con la base de datos, puede deberse a que la base de datos no esté funcionando, a que los datos de usuario no sean correctos, a que no esté activada la extensión pdo o (en el caso de SQLite) que el camino donde se quiere guardar la base de datos no exista.</p>

      <section id="conexion-sqlite">
        <h4>Conexión con SQLite 3</h4>

        <p>Para poder utilizar SQLite mediante PDO, debe estar activada la extensión pdo_sqlite en el archivo de configuración php.ini (véase el <a href="../otros/php-configuracion-1.html#pdo-sqlite">apartado extensión pdo_sqlite en la lección de configuración de Apache y PHP</a>).</p>

        <p>En SQLite, no se hace una conexión a un servidor, sino que simplemente se indica el archivo que va a contener la base de datos. En SQLite no hay un servidor que gestiona todas las bases de datos, sino que cada base de datos es un archivo independiente.</p>

        <p>Tenga en cuenta que PDO puede crear el archivo SQLite, pero no puede crear la ruta hasta el archivo, que debe existir previamente.</p>
        <ul>
          <li>Si se indica simplemente el nombre del archivo SQLite, el archivo se creará en el mismo directorio que se encuentra el programa PHP. No se aconseja hacerlo así por dos motivos. En primer lugar, porque al guardar la base de datos en un directorio público, cualquier visitante podría obtener la base de datos completa escribiendo su url. Ens egundo lugar, porque si las páginas del programa se encuentran distribuidas en varios directorios, cada página accedería a una base de datos distinta creada en cada directorio. Por eso se recomienda guardar el archivo SQLite en un directorio fuera del directorio público, teniendo en cuenta que el directorio debe existir y el servidor web debe tener permisos de escritura en él.</li>
        </ul>

        <div class="codigo copy">
          <pre>
<code class="language-php">// SQLITE: Conexión con la base de datos

function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("sqlite:$cfg[sqliteDatabase]");
        $tmp-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
        $tmp-&gt;query("PRAGMA foreign_keys = ON");
        $tmp-&gt;query("PRAGMA encoding = 'UTF-8'");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos. {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}

// CONEXIÓN CON LA BASE DE DATOS
// La conexión se debe realizar en cada página que acceda a la base de datos
$pdo = conectaDb();</code>
</pre>
        </div>

        <p><strong>Notas</strong>:</p>
        <ul>
          <li>El <a href="https://www.php.net/manual/en/ref.pdo-sqlite.connection.php">DSN para SQLite</a> sólo permite indicar la ubicación de la base de datos SQLite (que puede ser un archivo físico, en memoria o en un fichero temporal gestionado por PHP). En estos apuntes se utiliza siempre un archivo físico.</li>
          <li>El comando de SQLite "PRAGMA foreign keys = ON" es necesario para poder usar restricciones <a href="https://www.sqlite.org/foreignkeys.html">FOREIGN KEY en SQLite</a>.</li>
          <li>En las soluciones de los ejercicios proporcionadas en estos apuntes, los archivos se guardan en el directorio <strong>/tmp/</strong>. Para que funcionen las soluciones, se debe crear ese directorio o cambiarlo a otro.</li>
          <li>En caso de error, la función conectaDb() imprime unos mensajes de error y termina el programa. Si quisiéramos completar una página correcta, deberíamos imprimir el pie de página en caso de error y asegurarnos de que se ha escrito la cabecera antes de conectarse a la base de datos.</li>
        </ul>
      </section>

      <section id="conexion-mysql">
        <h4>Conexión con MySQL</h4>

        <p>En el caso de MySQL, para crear el objeto PDO se necesita proporcionar el nombre del servidor, el nombre de usuario de la base de datos y la contraseña. En el ejemplo siguiente esos datos se proporcionan como constantes que deberían definirse en el programa. El usuario de la base de datos se debe crear previamente.</p>

        <p>Para poder acceder a MySQL mediante PDO, debe estar activada la extensión php_pdo_mysql en el archivo de configuración php.ini (véase el <a href="../otros/php-configuracion-1.html#pdo-mysql">apartado extensión pdo_mysql en la lección de configuración de Apache y PHP</a>).</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// MYSQL: Conexión con la base de datos

function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("mysql:host=$cfg[mysqlHost];charset=utf8mb4", $cfg["mysqlUser"], $cfg["mysqlPassword"]);
        $tmp-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
        $tmp-&gt;setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos. {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}

// EJEMPLO DE USO DE LA FUNCIÓN conectaDb()
// La conexión se debe realizar en cada página que acceda a la base de datos
$pdo = conectaDb();</code>
</pre>
        </div>

        <p><strong>Notas</strong>:</p>
        <ul>
          <li>El <a href="https://www.php.net/manual/en/ref.pdo-mysql.connection.php">DSN para MySQL</a> permite indicar el servidor en el que se encuentra la base de datos, su puerto, el nombre de la base de datos y el juego de caracteres. En estos apuntes se indican únicamente el servidor (localhost) y el juego de caracteres (<a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-utf8mb4.html">utf8mb4</a>). El nombre de usuario de la base de datos y su contraseña se añaden como segundo y tercer parámetros.</li>
          </ul>
      </section>
    </section>

    <section id="create-drop">
      <h3>Creación y borrado de bases de datos y tablas: Consultas CREATE DATABASE, DROP DATABASE, CREATE TABLE, DROP TABLE</h3>

      <p>Las consultas de creación no son iguales en MySQL y SQLite. Para que una misma aplicación pueda trabajar con una u otra base de datos, en el apartado <a href="#configurable">aplicación configurable</a> estas consultas se incluyen en bibliotecas específicas.</p>
      <ul>
        <li>Las consultas de creación de bases de datos CREATE DATABASE suelen ser específicas de cada base de datos. En el caso de utilizar SQLite, en realidad no tiene sentido crear o borrar la base de datos ya que con SQLite cada base de datos es un fichero distinto y al conectar con la base de datos ya se dice con qué archivo se va a trabajar y se crea en caso necesario.</li>
        <li>Las consultas de creación de tablas CREATE TABLE suelen ser específicas de cada base de datos. Los ejemplos de este apartado no utilizan sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</li>
      </ul>

      <section id="create-sqlite">
        <h4>Creación y borrado de tablas en SQLite</h4>

        <p>Con SQLite no tiene sentido crear o borrar la base de datos, ya que SQLite trabaja con ficheros y cada fichero es una base de datos. Tan solo es necesario borrar y crear las tablas.</p>

        <p>Para borrar una tabla, se utiliza la consulta DROP TABLE. Esta consulta no es específica de SQlite y funcionaría con otras bases de datos. Se ha añadido la condición IF EXISTS porque en algunas versiones de SQLite la consulta DROP TABLE da error si la tabla no existe.</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// CONSULTA DE BORRADO DE TABLA

$consulta = "DROP TABLE IF EXISTS $cfg[tablaPersonas]";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al borrar la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Tabla borrada correctamente (si existía).&lt;/p&gt;\n";
}
print "\n";</code>
</pre>
        </div>

        <p>Para crear una tabla, se utiliza la consulta CREATE TABLE. Las consultas de creación de tabla suelen ser específicas de cada base de datos. El ejemplo no utiliza sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// SQLITE: CONSULTA DE CREACIÓN DE TABLA

$consulta = "CREATE TABLE $cfg[tablaPersonas]  (
             id INTEGER PRIMARY KEY,
             nombre VARCHAR($cfg[tablaPersonasTamNombre]),
             apellidos VARCHAR($cfg[tablaPersonasTamApellidos])
             )";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
}
print "\n";</code>
</pre>
        </div>
      </section>

      <section id="create-mysql">
        <h4>Creación y borrado de bases de datos y tablas en MySQL</h4>

        <p>Con MySQL, borraremos la base de datos (y las tablas existentes), crearemos de nuevo la base de datos y crearemos la tabla.</p>

        <p>Para borrar una base de datos, se utiliza la consulta DROP DATABASE. Se ha añadido la condición IF EXISTS porque en algunas bases de datos la consulta DROP DATABASE da error si la tabla no existe.</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// MYSQL: CONSULTA DE BORRADO DE BASE DE DATOS

$consulta = "DROP DATABASE IF EXISTS $cfg[mysqlDatabase]";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al borrar la base de datos. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Base de datos borrada correctamente (si existía).&lt;/p&gt;\n";
}
print "\n";</code>
</pre>
        </div>

        <p>Para crear una base de datos, se utiliza la consulta CREATE DATABASE.</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// MYSQL: CONSULTA DE CREACIÓN DE BASE DE DATOS

$consulta = "CREATE DATABASE $cfg[mysqlDatabase]
             CHARACTER SET utf8mb4
             COLLATE utf8mb4_unicode_ci";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la base de datos. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Base de datos creada correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>

        <p><strong>Nota</strong>: El juego de caracteres utilizado en este curso es <strong>UTF-8</strong>, por lo que en la base de datos MySQL se utiliza el juego de caracteres <strong>utf8mb4</strong> (que permite almacenar cualquier carácter Unicode) y el cotejamiento <strong>utf8mb4_unicode_ci</strong> (que implementa todos los criterios de ordenación de Unicode). Para una explicación más detallada se puede consultar <a href="https://mathiasbynens.be/notes/mysql-utf8mb4">el blog de Mathias Bynens</a>.</p>

        <p>Para crear una tabla, se utiliza la consulta CREATE TABLE. Las consultas de creación de tabla suelen ser específicas de cada base de datos. El ejemplo no utiliza sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</p>

        <div class="codigo copy">
          <pre>
<code class="language-php">// MYSQL: CONSULTA DE CREACIÓN DE TABLA

$consulta = "CREATE TABLE $cfg[tablaPersonas]  (
             id INTEGER UNSIGNED AUTO_INCREMENT,
             nombre VARCHAR($cfg[tablaPersonasTamNombre]),
             apellidos VARCHAR($cfg[tablaPersonasTamApellidos]),
             PRIMARY KEY(id)
             )";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
}</code>
</pre>
        </div>
      </section>
    </section>

    <section id="insert-update-delete">
      <h3>Creación, actualización y borrado de registros: Consultas INSERT INTO, UPDATE, DELETE FROM</h3>

      <p>Estas consultas son iguales en MySQL y SQLite.</p>

      <ul>
        <li>Para añadir un registro a una tabla, se utiliza la consulta INSERT INTO.

          <div class="codigo copy">
            <pre>
<code class="language-php">// CONSULTA DE INSERCIÓN DE REGISTRO

$nombre    = "Pepito";            // Normalmente estos valores vendrán de un formulario
$apellidos = "Conejo";

$consulta = "INSERT INTO $cfg[tablaPersonas]
             (nombre, apellidos)
             VALUES (:nombre, :apellidos)";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":nombre" =&gt; $nombre, ":apellidos" =&gt; $apellidos])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Registro creado correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
        <li>Para modificar un registro a una tabla, se utiliza la consulta UPDATE.

          <div class="codigo copy">
            <pre>
<code class="language-php">// CONSULTA DE MODIFICACIÓN DE REGISTRO

$id        = "1";                 // Normalmente estos valores vendrán de un formulario
$nombre    = "Pepita";
$apellidos = "Conejo";

$consulta = "UPDATE $cfg[tablaPersonas]
             SET nombre=:nombre, apellidos=:apellidos
             WHERE id=:id";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":nombre" =&gt; $nombre, ":apellidos" =&gt; $apellidos, ":id" =&gt; $id])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Registro modificado correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Para borrar un registro de una tabla, se utiliza la consulta DELETE FROM.

          <p><strong>Nota</strong>: En el ejemplo siguiente los registros a borrar se reciben en forma de matriz y se recorre la matriz borrando un elemento en cada iteración.</p>

          <div class="codigo copy">
            <pre>
<code class="language-php">// CONSULTA DE BORRADO DE REGISTROS

$id = [1 =&gt; "on", 3 =&gt; "on"];     // Normalmente este valor vendrá de un formulario (en este caso, como matriz).

foreach ($id as $indice =&gt; $valor) {
    $consulta = "DELETE FROM $cfg[tablaPersonas]
                 WHERE id=:indice";

    $resultado = $pdo-&gt;prepare($consulta);
    if (!$resultado) {
        print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } elseif (!$resultado-&gt;execute([":indice" =&gt; $indice])) {
        print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Registro borrado correctamente.&lt;/p&gt;\n";
        print "\n";
    }
}</code>
</pre>
          </div>
        </li>
      </ul>

      <hr class="corta">

      <p>Si el campo es de tipo numérico, y el valor a insertar es una cadena (como ocurre cuando recogemos el dato de un formulario), podríamos tener un problema de tipos al insertarlo. En el caso de los sistemas gestores de bases de datos que se usan en este curso (SQLite y MariaDB/MySQL de forma general, PostgreSQL en algún ejercicio) la conversión de tipos es automática y la cadena se convierte automáticamente en un valor numérico, pero puede que en otros sistemas la conversión no se realice y se produzca un error.</p>

      <p>Si nos encontráramos con este problema, deberíamos realizar la conversión de cadena a entero. Para ello podríamos usar la función de PHP <a href="https://www.php.net/manual/en/function.intval.php"><span class="php-fun">intval()</span></a> como muestra el ejemplo siguiente en el que "edad" sería un campo INTEGER:</p>
      <div class="codigo">
        <pre>
<code class="language-php">$consulta = "INSERT INTO $cfg[tablaPersonas]
              (nombre, edad)
              VALUES (:nombre, :edad)";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":nombre" =&gt; $nombre, <span class="codigo-resaltado">":edad" =&gt; intval($edad)</span>])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Registro creado correctamente.&lt;/p&gt;\n";
}</code>
</pre>
      </div>

      <p>En las soluciones de los ejercicios de estos apuntes no se realiza la conversión, ya que SQLite, MySQL o PostgreSQL no lo necesitan.</p>
    </section>

    <section id="select">
      <h3>Selección de registros: Consulta SELECT</h3>

      <p>Para obtener registros que cumplan determinados criterios se utiliza una consulta SELECT. Estas consultas son iguales en MySQL y SQLite.</p>
      <ul>
        <li>Si la consulta devuelve un único registro con una sola columna se puede utilizar el método <a href="https://www.php.net/manual/en/pdostatement.fetchcolumn.php">PDOStatement-&gt;fetchColumn()</a> para recuperar el dato.

          <div class="codigo copy">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA
$consulta = "SELECT COUNT(*) FROM $cfg[tablaPersonas]";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;La tabla contiene {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve un único registro, se puede utilizar el método <a href="https://www.php.net/manual/en/pdostatement.fetch.php">PDOStatement-&gt;fetch()</a> para recuperar el registro en forma de matriz. De forma predeterminada, los valores del registro aparecen repetidos en la matriz y para acceder a los valores se puede utilizar como índice tanto los nombres de las columnas de la tabla como números enteros correlativos (0, 1, 2, etc.). Si se envía como argumento la constante PDO::FETCH_ASSOC, los índices de la matriz son únicamente los nombres de las columnas de la tabla.
          <div class="codigo copy">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO (O NINGUNO)

$id = 1       // Normalmente este valor vendrá de un formulario

$consulta  = "SELECT * FROM <i>tabla</i> WHERE id=:id";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":id" =&gt; $id])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    $registro = $resultado-&gt;fetch();
    print "    &lt;p&gt;&lt;strong&gt;Registro obtenido&lt;/strong&gt;&lt;/p&gt;\n";
    print "\n";
    print "    &lt;p&gt;$registro[id] - $registro[nombre] - $registro[apellidos].&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve varios registros (es decir, que la consulta puede potencialmente devolver varios registros, aunque igual no devuelve ninguno, o devuelve sólo uno, dependiendo de la consulta concreta y de los registros guardados), para acceder a los registros devueltos por la consulta ...

          <ul>
            <li>Habitualmente se utiliza un bucle <span class="php-res">foreach</span> para recorrer todos los registros devueltos. Es importante tener en cuenta que sólo se puede iterar una vez sobre el resultado de la consulta, ya que los registros se van eliminado del resultado de la consulta.

              <div class="codigo copy">
                <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta = "SELECT * FROM $cfg[tablaPersonas]";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
    print "    &lt;ul&gt;\n";
    foreach ($resultado as $registro) {
        print "      &lt;li&gt;$registro[id] - $registro[nombre] - $registro[apellidos]&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
              </div>
            </li>
            <li>Para este caso también se puede utilizar un bucle <span class="php-res">while</span> y el método <a href="https://www.php.net/manual/en/pdostatement.fetch.php"><span class="php-fun">PDOStatement-&gt;fetch()</span></a>, que recupera el primer registro de la consulta. Es importante tener en cuenta que sólo se puede iterar una vez sobre el resultado de la consulta, ya que los registros se van eliminado del resultado de la consulta.
              <div class="codigo">
                <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta = "SELECT * FROM $cfg[tablaPersonas]";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
    print "    &lt;ul&gt;\n";
    while ($registro = $resultado-&gt;fetch()) {
        print "      &lt;li&gt;$registro[id] - $registro[nombre] - $registro[apellidos]&lt;/li&gt;\n";
        print "\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
              </div>
            </li>

            <li>Los dos ejemplos anteriores (con <span class="php-res">foreach</span> o <span class="php-fun">fetch()</span>) escribirían una lista vacía en el caso en el que la consulta no devolviera ningún registro, ya que no escribirían nada. Si en ese caso queremos mostrar un mensaje informativo, podríamos hacer primero una consulta que cuente el número de resultados de la consulta y, si es mayor que cero, hacer la consulta que recupera los registros.

              <div class="codigo">
                <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta = "SELECT COUNT(*) FROM $cfg[tablaPersonas]";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif ($resultado-&gt;fetchColumn() == 0) {
    print "    &lt;p&gt;No se ha creado todavía ningún registro en la tabla.&lt;/p&gt;\n";
} else {
    $consulta = "SELECT * FROM $cfg[tablaPersonas]";

    $resultado = $pdo-&gt;query($consulta);
    if (!$resultado) {
        print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
        print "    &lt;ul&gt;\n";
        foreach ($resultado as $registro) {
            print "      &lt;li&gt;$registro[id] - $registro[nombre] - $registro[apellidos]&lt;/li&gt;\n";
        }
        print "    &lt;/ul&gt;\n";
        print "\n";
    }
}</code>
</pre>
              </div>
            </li>

            <li>Podemos hacer lo mismo con una sola consulta utilizando el método <a href="https://www.php.net/manual/en/pdostatement.fetchall.php">PDOStatement-&gt;fetchAll()</a>, que recupera todos los registros devueltos por la consulta en forma de matriz.

              <div class="codigo copy">
                <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)

$consulta = "SELECT * FROM $cfg[tablaPersonas]";

$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!count($registros = $resultado-&gt;fetchAll())) {
    print "    &lt;p class=\"aviso\"&gt;No se ha creado todavía ningún registro.&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;\n";
    print "    &lt;ul&gt;\n";
    foreach ($registros as $registro) {
        print "      &lt;li&gt;$registro[id] - $registro[nombre] - $registro[apellidos]&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ul>
    </section>

    <section id="select-like">
      <h3>Selección de registros: Consulta SELECT LIKE</h3>

      <p>La consulta SELECT permite efectuar búsquedas en cadenas utilizando el condicional LIKE o NOT LIKE y los comodines _ (cualquier carácter) o % (cualquier número de caracteres). Estas consultas son iguales en MySQL y SQLite.</p>

      <p>Ejemplos de consultas:</p>
      <ul>
        <li>Registros en los que el apellido empieza por la cadena recibida:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA

$apellidos = "con";           // Normalmente este valor vendrá de un formulario

$consulta = "SELECT COUNT(*) FROM $cfg[tablaPersonas]
             WHERE apellidos LIKE :apellidos";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":apellidos" =&gt; <span class="codigo-resaltado">"$apellidos%"</span>])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
        <li>Registros en los que el apellido contiene la cadena recibida:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA

$apellidos = "nej";           // Normalmente este valor vendrá de un formulario

$consulta = "SELECT COUNT(*) FROM $cfg[tablaPersonas]
             WHERE apellidos LIKE :apellidos";

$resultado = $pdo-&gt;prepare($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error al preparar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} elseif (!$resultado-&gt;execute([":apellidos" =&gt; <span class="codigo-resaltado">"%$apellidos%"</span>])) {
    print "    &lt;p class=\"aviso\"&gt;Error al ejecutar la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
      </ul>

      <hr class="corta">

      <p>Si el campo es de tipo numérico, y la cadena de búsqueda es una cadena, podríamos tener un problema de tipos al compararlos. En el caso de muchas bases de datos (como SQLite o MySQL) la conversión de tipos es automática y el valor numérico de la base de datos se convierte automáticamente en una cadena para permitir la búsqueda la cadena de búsqueda, pero en otras (como PostgreSQL) la conversión no se realiza y se produce un error.</p>

      <p>Para escribir consultas que se puedan ejecutar sin problemas en el mayor número de sistemas gestores de bases de datos, es recomendable realizar la conversión usando la función SQL como muestra el ejemplo siguiente en el que "edad" sería un campo INTEGER:</p>
      <div class="codigo">
        <pre>
<code class="language-php">$consulta = "SELECT * FROM $cfg[tablaPersonas]
             WHERE nombre LIKE :nombre
             AND <span class="codigo-resaltado">CAST(edad AS VARCHAR)</span> LIKE :edad
             ORDER BY $ordena";</code>
</pre>
      </div>
    </section>

    <section id="union-tablas">
      <h3>Consultas de unión de tablas</h3>

      <p>Se pueden también realizar consultas de unión entre varias tablas, como en el ejemplo siguiente. El ejemplo está sacado del <a href="../ejercicios/bases-de-datos-viejos/biblioteca-1.html">ejercicio de Biblioteca</a> y devuelve los préstamos pendientes de devolver a partir de tres tablas de Usuarios, Obras y Préstamos:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// CONSULTA DE UNIÓN DE TABLAS

$consulta = "SELECT
               $cfg[tablaPrestamos].id AS id,
               $cfg[tablaUsuarios].nombre as nombre,
               $cfg[tablaUsuarios].apellidos as apellidos,
               $cfg[tablaObras].titulo as titulo,
               $cfg[tablaPrestamos].prestado as prestado,
               $cfg[tablaPrestamos].devuelto as devuelto
             FROM $cfg[tablaPrestamos], $cfg[tablaUsuarios], $cfg[tablaObras]
             WHERE
               $cfg[tablaPrestamos].id_usuario=$cfg[tablaUsuarios].id
               AND $cfg[tablaPrestamos].id_obra=$cfg[tablaObras].id
               AND $cfg[tablaPrestamos].devuelto='0000-00-00'
             ORDER BY $columna $orden";
$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
} else {
   ...</code>
</pre>
      </div>
    </section>
  </section>

  <section id="configurable">
    <h2>Aplicación configurable</h2>

    <p>En los ejercicios en este curso se propone al alumno organizar los programas de manera que puedan trabajar tanto con SQLite como con MySQL y hacerlo de forma organizada, para que se puedan añadir fácilmente otras bases de datos.</p>

    <p>Para ello distribuiremos los elementos comunes (constantes, variables y funciones) en cuatro ficheros distintos</p>
    <ul>
      <li>config.php. En este fichero escribiremos las opciones de configuración a disposición del usuario.</li>
      <li>biblioteca.php. En este fichero escribiremos los elementos comunes que no dependen de la base de datos utilizada.</li>
      <li>biblioteca-sqlite.php. En este fichero escribiremos los elementos comunes que necesitan adaptarse para utilizar SQLite.</li>
      <li>biblioteca-mysql.php. En este fichero escribiremos los elementos comunes que necesitan adaptarse para utilizar MySQL.</li>
    </ul>

    <p>Todas las páginas de la aplicación cargarán la biblioteca general, que a su vez cargará el fichero de configuración y una de las dos bibliotecas específicas, de acuerdo con la configuración escogida por el usuario.</p>

    <p>
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="450" height="360" viewBox="0 0 450 360" style="background-color: white;" font-family="sans-serif" class="izquierda">
        <defs>
          <marker id="flechaNegra" markerWidth="12" markerHeight="12" refX="0" refY="6" orient="auto">
            <path d="M0,4 L0,8 L6,6" style="fill: black;" />
          </marker>
          <marker id="flechaRoja" markerWidth="12" markerHeight="12" refX="0" refY="6" orient="auto">
            <path d="M0,4 L0,8 L6,6" style="fill: red;" />
          </marker>
          <marker id="flechaAzul" markerWidth="12" markerHeight="12" refX="0" refY="6" orient="auto">
            <path d="M0,4 L0,8 L6,6" style="fill: blue;" />
          </marker>
          <marker id="flechaVerde" markerWidth="12" markerHeight="12" refX="0" refY="6" orient="auto">
            <path d="M0,4 L0,8 L6,6" style="fill: green;" />
          </marker>
        </defs>

        <!-- Bibliotecas -->
        <text x="10" y="20" text-anchor="start" font-family="sans-serif" font-size="14">Todas las páginas incluyen biblioteca.php</text>
        <svg x="10" y="40">
          <text x="135" y="20" text-anchor="middle" font-family="sans-serif" font-size="14">biblioteca.php</text>
          <rect x="25" y="30" width="220" height="270" fill="none" stroke="black" stroke-width="2" />

          <text x="30" y="50" text-anchor="left" font-family="sans-serif" font-size="14">&lt;?php</text>
          <text x="30" y="70" text-anchor="left" font-family="sans-serif" font-size="14">...</text>
          <text x="30" y="100" text-anchor="left" font-family="sans-serif" font-size="14">include "config.php";</text>
          <text x="30" y="120" text-anchor="left" font-family="sans-serif" font-size="14">...</text>
          <text x="30" y="160" text-anchor="left" font-family="sans-serif" font-size="14">if (SQLite) {</text>
          <text x="40" y="180" text-anchor="left" font-family="sans-serif" font-size="14">include "biblioteca-sqlite.php"</text>
          <text x="30" y="200" text-anchor="left" font-family="sans-serif" font-size="14">} elseif (MySQL) {</text>
          <text x="40" y="220" text-anchor="left" font-family="sans-serif" font-size="14">include "biblioteca-mysql.php"</text>
          <text x="30" y="240" text-anchor="left" font-family="sans-serif" font-size="14">}</text>
          <text x="30" y="260" text-anchor="left" font-family="sans-serif" font-size="14">...</text>

          <line x1="246" y1="94" x2="290" y2="50" stroke="green" stroke-width="2" style="marker-end: url(#flechaVerde)" />
          <text x="272" y="60" text-anchor="middle" font-family="sans-serif" fill="green" font-size="12" transform="rotate(-45 270 60)">include</text>
          <text x="335" y="10" text-anchor="middle" font-family="sans-serif" font-size="14">config.php</text>
          <rect x="300" y="20" width="70" height="50" fill="none" stroke="black" stroke-width="2" />

          <line x1="246" y1="194" x2="290" y2="150" stroke="green" stroke-width="2" style="marker-end: url(#flechaVerde)" />
          <text x="272" y="160" text-anchor="middle" font-family="sans-serif" fill="green" font-size="12" transform="rotate(-45 270 160)">include</text>
          <text x="335" y="110" text-anchor="middle" font-family="sans-serif" font-size="14">biblioteca-sqlite.php</text>
          <rect x="300" y="120" width="70" height="50" fill="none" stroke="black" stroke-width="2" />

          <line x1="246" y1="196" x2="290" y2="240" stroke="green" stroke-width="2" style="marker-end: url(#flechaVerde)" />
          <text x="262" y="233" text-anchor="middle" font-family="sans-serif" fill="green" font-size="12" transform="rotate(45 262 233)">include</text>
          <text x="335" y="210" text-anchor="middle" font-family="sans-serif" font-size="14">biblioteca-mysql.php</text>
          <rect x="300" y="220" width="70" height="50" fill="none" stroke="black" stroke-width="2" />
        </svg>
      </svg>
    </p>

    <section id="conexion-configurable">
      <h3>Conexión configurable</h3>

      <p>Por ejemplo, para el caso de la función de conexión, el resultado sería:</p>
      <ul>
        <li>config.php: en este fichero se especifica la base de datos que se va a utilizar:

          <div class="codigo">
            <pre>
<code class="language-php">// config.php
// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN

// Base de datos utilizada por la aplicación

$cfg["dbMotor"] = SQLITE;                                   // Valores posibles: MYSQL o SQLITE

// Configuración para SQLite

$cfg["sqliteDatabase"] = "/tmp/db.sqlite";                  // Ubicación de la base de datos

// Configuración para MySQL

$cfg["mysqlHost"]     = "localhost";                        // Nombre de host
$cfg["mysqlUser"]     = "";                                 // Nombre de usuario
$cfg["mysqlPassword"] = "";                                 // Contraseña de usuario
$cfg["mysqlDatabase"] = "";                                 // Nombre de la base de datos</code>
</pre>
          </div>
        </li>
        <li>biblioteca.php: la configuración establecida en config.php determina la biblioteca específica a cargar:

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca.php

// CONSTANTES
define("SQLITE", 1);
define("MYSQL", 2);

require_once "config.php";

if ($cfg["dbMotor"] == SQLITE) {
    require_once "biblioteca-sqlite.php";
} elseif ($cfg["dbMotor"] == MYSQL) {
    require_once "biblioteca-mysql.php";
}</code>
</pre>
          </div>
        <li>biblioteca-sqlite.php: contiene la definición de la función conectaDb() específica para trabajar con SQLite

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-sqlite.php

// SQLITE: Conexión con la base de datos

function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("sqlite:$cfg[sqliteDatabase]");
        $tmp-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
        $tmp-&gt;query("PRAGMA foreign_keys = ON");
        $tmp-&gt;query("PRAGMA encoding = 'UTF-8'");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos. {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}</code>
</pre>
          </div>
        </li>
        </li>
        <li>biblioteca-mysql.php: contiene la definición de la función conectaDb() específica para trabajar con MySQL

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-mysql.php

// MYSQL: Conexión con la base de datos

function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("mysql:host=$cfg[mysqlHost];charset=utf8mb4", $cfg["mysqlUser"], $cfg["mysqlPassword"]);
        $tmp-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
        $tmp-&gt;setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos. {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}</code>
</pre>
          </div>
        </li>
        <li>finalmente, en cualquier fichero que quiera conectar con la base de datos se llamaría a la biblioteca general y se llamaría a la función genérica conectaDb():

          <div class="codigo">
            <pre>
<code class="language-php">// EJEMPLO DE USO DE CONEXIÓN CONFIGURABLE
// La conexión se debe realizar en cada página que acceda a la base de datos

require_once "biblioteca.php";

$pdo = conectaDb();</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="create-drop-configurable">
      <h4>Borrado y creación de base de datos y tablas configurable</h4>

      <p>El resultado sería</p>
      <ul>
        <li>config.php: contiene las variables de configuración del programador comunes:

          <div class="codigo">
            <pre>
<code class="language-php">// config.php
// Configuración de la tabla Personas

$cfg["tablaPersonasTamNombre"]    = 40;                     // Tamaño de la columna Personas &gt; Nombre
$cfg["tablaPersonasTamApellidos"] = 60;                     // Tamaño de la columna Personas &gt; Apellidos</code>
</pre>
          </div>
        </li>
        <li>biblioteca-sqlite.php: contiene las variables de configuración del programador específicas de SQLite y la definición de la función borraTodo() específica para trabajar con SQLite:

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-sqlite.php
// FUNCIONES ESPECÍFICAS DE LA BASE DE DATOS SQLITE

// SQLITE: Nombres de las tablas

$cfg["tablaPersonas"] = "personas";                       // Nombre de la tabla Personas

// SQLITE: Consultas de borrado y creación de tablas

function borraTodo()
{
    global $pdo, $cfg;

    $consulta = "DROP TABLE IF EXISTS $cfg[tablaPersonas]";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al borrar la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Tabla borrada correctamente (si existía).&lt;/p&gt;\n";
    }
    print "\n";

    $consulta = "CREATE TABLE $cfg[tablaPersonas]  (
                 id INTEGER PRIMARY KEY,
                 nombre VARCHAR($cfg[tablaPersonasTamNombre]),
                 apellidos VARCHAR($cfg[tablaPersonasTamApellidos])
                 )";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
    }
    print "\n";
}</code>
</pre>
          </div>
        </li>
        <li>biblioteca-mysql.php: contiene las variables de configuración del programador específicas de MySQL y la definición de la función borraTodo() específica para trabajar con MySQL

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-mysql.php
// FUNCIONES ESPECÍFICAS DE LA BASE DE DATOS MYSQL

// MYSQL: Nombres de las tablas

$cfg["tablaPersonas"] = "$cfg[mysqlDatabase].personas";   // Nombre de la tabla Personas

// MYSQL: Consultas de borrado y creación de base de datos y tablas

function borraTodo()
{
    global $pdo, $cfg;

    $consulta = "DROP DATABASE IF EXISTS $cfg[mysqlDatabase]";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al borrar la base de datos. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Base de datos borrada correctamente (si existía).&lt;/p&gt;\n";
    }
    print "\n";

    $consulta = "CREATE DATABASE $cfg[mysqlDatabase]
                 CHARACTER SET utf8mb4
                 COLLATE utf8mb4_unicode_ci";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al crear la base de datos. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Base de datos creada correctamente.&lt;/p&gt;\n";
        print "\n";

        $consulta = "CREATE TABLE $cfg[tablaPersonas]  (
                     id INTEGER UNSIGNED AUTO_INCREMENT,
                     nombre VARCHAR($cfg[tablaPersonasTamNombre]),
                     apellidos VARCHAR($cfg[tablaPersonasTamApellidos]),
                     PRIMARY KEY(id)
                     )";

        if (!$pdo-&gt;query($consulta)) {
            print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla. SQLSTATE[{$pdo-&gt;errorCode()}]: {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
        } else {
            print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
        }
    }
}</code>
</pre>
          </div>
        </li>
        <li>finalmente, en el fichero que quiera reiniciar la base de datos se llamaría a la biblioteca general y se llamaría a la función genérica borraTodo():

          <div class="codigo">
            <pre>
<code class="language-php">// EJEMPLO DE USO DE BORRADO CONFIGURABLE

require_once "biblioteca.php";

$pdo = conectaDb();

borraTodo();

$pdo = null;</code>
</pre>
          </div>
        </li>
      </ul>
    </section>
  </section>

  <footer>
    <p class="ultmod">Última modificación de esta página: 20 de diciembre de 2022</p>

    <p class="licencia">
      <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES"><img src="../varios/iconos/icono-cc-by-sa.svg" alt="Licencia Creative Commons" title="Licencia Creative Commons BY-SA" width="120" height="42"></a><br>
      Esta página forma parte del curso <strong><a href="https://www.mclibre.org/consultar/php/">Programación web en PHP</a></strong> por <a href="https://www.mclibre.org/" rel="author">Bartolomé Sintes Marco</a><br>
      que se distribuye bajo una <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES">Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)</a>.
    </p>
  </footer>
</body>
</html>
