<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>PHP Data Objects (PDO). PHP. Bartolomé Sintes Marco. www.mclibre.org</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../varios/php.css" title="mclibre">
  <link rel="icon" href="../varios/favicon.svg">
  <link rel="stylesheet" href="../varios/prism.css">
  <script src="../varios/prism-copy.js"></script>
  <script src="../varios/prism.js"></script>
  <script src="../varios/clipboard.min.js"></script>
</head>

<body>
  <h1>PHP Data Objects (PDO)</h1>

  <nav>
    <p>
      <a href="../index.html"><img src="../varios/iconos/icono-php.svg" alt="Índice de PHP" title="Índice de PHP" width="48" height="48"></a>
      <a href="#"><img src="../varios/iconos/icono-arrow-circle-up.svg" alt="Principio de la página" title="Principio de la página" width="36" height="36"></a>
    </p>

    <div class="toc">
      <h2>PHP Data Objects (PDO)</h2>

      <ul>
        <li><a href="#conceptos-basicos">Conceptos básicos</a></li>
        <li><a href="#seguridad">Consultas preparadas</a></li>
        <li><a href="#ejemplos-codigo">Ejemplos SQLite / MySQL</a>
          <ul>
            <li><a href="#opciones">Opciones del programa</a></li>
            <li><a href="#conexion">Conexión</a></li>
            <li><a href="#create-drop">CREATE, DROP</a></li>
            <li><a href="#insert-update-delete">INSERT, UPDATE, DELETE</a></li>
            <li><a href="#select">SELECT</a></li>
            <li><a href="#select-like">SELECT LIKE</a></li>
            <li><a href="#union-tablas">unión de tablas</a></li>
          </ul>
        </li>
        <li><a href="#configurable">Aplicación configurable</a>
          <ul>
            <li><a href="#conexion-configurable">Conexión configurable</a></li>
            <li><a href="#create-drop-configurable">CREATE configurable</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </nav>

  <p>La extensión <a href="https://www.php.net/manual/en/book.pdo.php">PDO (PHP Data Objects)</a> permite acceder a distintas bases de datos (MySQL/MariaBD, PostgreSQL, Oracle, MS SQL Server, SQLite, Firebird, DB2, Informix, etc.) de una forma uniforme, lo que facilita la portabilidad de las aplicaciones. La portabilidad entre bases de datos no es absoluta debido por ejemplo a las diferencias entre diferentes bases de datos en aspectos como la forma de conectarse o la sintaxis del lenguaje de definición de datos. Para ilustrar esas diferencias y como tratarlas adecuadamente, se ofrecen ejemplos de código específicos para SQLite y para MySQL.</p>

  <p>La extensión PDO no evalúa la corrección de las consultas SQL, aunque sí implementa algunas medidas de seguridad mediante consultas preparadas, como se comenta en el apartado correspondiente.</p>

  <section id="conceptos-basicos">
    <h2>Conceptos básicos de PDO</h2>

    <p>PDO es una biblioteca de PHP orientada a objetos, pero se puede utilizar sin problemas en un programa no orientado a objetos. Tan solo será necesario utilizar la notación propia de la orientación orientada a objetos al manipular el objeto PDO.</p>

    <section id="basicos-conexion">
      <h3>Conexión con la base de datos</h3>

      <p>Para trabajar con una base de datos en nuestro programa, simplemente nos conectaremos con la base de datos creando un objeto PDO. La información necesaria para la conexión con la base de datos específica se incluye como argumento:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// CONEXIÓN CON LA BASE DE DATOS
$pdo = new PDO("<i>informacion-para-la-conexion</i>");</code>
</pre>
      </div>
    </section>

    <section id="basicos-ejecucion">
      <h3>Ejecución de las consultas</h3>

      <p>Una vez realizada la conexión, las consultas SQL se realizar a través del objeto PDO. La ejecución de la consulta y el tratamiento de la respuesta se puede hacer de cuatro formas distintas, atendiendo a dos criterios:</p>

      <p>Por un lado, se debe considerar si la consulta incluye información que nos ha llegado a través de un formulario.</p>
      <ul>
        <li>Si la consulta <strong>no</strong> incluye datos provinientes de un formulario, se puede utilizar el método <a href="https://www.php.net/manual/en/pdo.query.php"><span class="php-fun">PDO-&gt;query(<i>consulta</i>)</span></a>:
          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA SIN DATOS PROVENIENTES DE UN FORMULARIO
$pdo-&gt;query("<i>consulta</i>");</code>
</pre>
          </div>
        </li>
        <li>Si la consulta <strong>sí</strong> incluye datos provinientes de un formulario, se deben utlizar consultas preparadas para evitar ataques de inyección SQL de los que el método query() no nos protege. El método para efectuar consultas es primero preparar la consulta con <a href="https://www.php.net/manual/en/pdo.prepare.php"><span class="php-fun">PDO-&gt;prepare(<i>consulta</i>)</span></a> y después ejecutarla con <span class="php-fun"><a href="https://www.php.net/manual/en/pdostatement.execute.php">PDO-&gt;execute(<i>[parámetros]</i>)</a></span>, que devuelve el resultado de la consulta.
          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA CON DATOS PROVENIENTES DE UN FORMULARIO
$resultado = $pdo-&gt;prepare("<i>consulta</i>");
$resultado-&gt;execute([<i>parámetros de la consulta</i>]);</code>
</pre>
          </div>
        </li>
      </ul>

      <p>Por otro lado, se debe considerar si la consulta puede devolver registros:</p>
      <ul>
        <li>Si por el tipo de consulta de que se trata sabemos que la consulta <strong>no</strong> va a devolver registros, la consulta (preparada o no) devolverá simplemente <span class="php-con">true</span> (si la consulta se realiza con éxito) o <span class="php-con">false</span> (si la consulta falla). En ese caso podemos utilizar directamente el resultado de la consulta en una estructura <span class="php-res">if ... else ...</span> para gestionar las tareas a realizar en cada caso. Conviene escribir la condición en negativo (con exclamación delante), para escribir en primer lugar el caso en el que la consulta falle, que normalmente contendrá menos líneas de programa:
          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA QUE NO VA A DEVOLVER REGISTROS
if (!$pdo-&gt;query("<i>consulta</i>")) {
    ...        // Si la consulta falla
} else {
    ...        // Si la consulta se ejecuta correctamente
}</code>
</pre>
          </div>
        </li>
        <li>Si la consulta puede devolver registros, devolverá <span class="php-con">false</span> (si la consulta falla) o cero, uno o varios registros. En ese caso conviene guardar el resultado de la consulta en una variable auxiliar y escribir la estructura <span class="php-res">if ... else ...</span> a partir de esa variable auxiliar:

          <div class="codigo">
            <pre>
<code class="language-php">// EJECUCIÓN DE UNA CONSULTA QUE PUEDE DEVOLVER REGISTROS
$resultado = $pdo-&gt;query("<i>consulta</i>")
if (!$resultado) {
    ...        // Si la consulta falla
} else {
    ...        // Si la consulta se ejecuta correctamente
}</code>
</pre>
          </div>
        </li>
      </ul>

      <p>En los ejemplos anteriores se ha escrito la consulta en la llamada al método, pero es habitual definir una variable $consulta que contenga la consulta y utilizar esa variable en la llamada al método:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// En una sola línea de programa
$resultado = $pdo-&gt;query("SELECT * FROM <i>tabla</i>");

// En dos líneas de programa
$consulta  = "SELECT * FROM <i>tabla</i>";
$resultado = $pdo-&gt;query($consulta);</code>
</pre>
      </div>

      <p>Utilizar una variable auxiliar permite por ejemplo imprimir la consulta mientras se está programando para comprobar que no tiene errores, o poder en un futuro agrupar las consultas en un fichero aparte.</p>

      <div class="codigo">
        <pre>
<code class="language-php">$consulta = "SELECT * FROM <i>tabla</i>";
print "&lt;p&gt;Consulta: $consulta&lt;/p&gt;\n";
// var_dump($consulta);
$resultado  = $pdo-&gt;query($consulta);</code>
</pre>
      </div>
    </section>

    <section id="basicos-resultado">
      <h3>Gestión de los registros devueltos por la consulta</h3>

      <p>Cuando la consulta puede devolver registros, se debe guardar la respuesta en una variable auxiliar. Esa variable es de un tipo especial llamado <a href="https://www.php.net/manual/en/language.types.resource.php">recurso</a> que no se puede acceder directamente, pero de la que podemos ir extrayendo uno a uno los registros mediante un bucle <span class="php-res">foreach ()</span> o mediante los métodos fetch() o fetchColumn():</p>

      <ul>
        <li>Si la consulta devuelve un único registro que contiene la respuesta buscada en la primera columna se puede utilizar la función <a href="https://www.php.net/manual/en/pdostatement.fetchcolumn.php">PDOStatement-&gt;fetchColumn()</a> para recuperar la primera columna del registro.

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA
$consulta  = "SELECT COUNT(*) FROM <i>tabla</i>";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;La tabla contiene {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve un único registro, se puede utilizar la función <a href="https://www.php.net/manual/en/pdostatement.fetch.php">PDOStatement-&gt;fetch()</a> para recuperar el registro en forma de matriz. De forma predeterminada, los valores del registro aparecen repetidos en la matriz y para acceder a los valores se puede utilizar como índice tanto los nombres de las columnas de la tabla como números enteros correlativos (0, 1, 2, etc.). Si se envía como argumento la constante PDO::FETCH_ASSOC, los índices de la matriz son únicamente los nombres de las columnas de la tabla.

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO (O NINGUNO)
$valor = <i>valor</i>;       // Normalmente este valor vendrá de un formulario

$consulta  = "SELECT * FROM <i>tabla</i> WHERE <i>id</i>=<i>:id</i>";   // Normalmente solo habrá un registro (o ninguno) con un id determinado
$resultado = $pdo-&gt;prepare($consulta);
$resultado -&gt;execute(["<i>:id</i>" =&gt; $valor);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    $valor = $resultado-&gt;fetch();
    print "    &lt;p&gt;&lt;strong&gt;Registro obtenido&lt;/strong&gt;&lt;/p&gt;";
    print "\n";
    print "    &lt;p&gt;$valor[<i>columna1</i>] - $valor[<i>columna2</i>] - etc.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve varios registros, la variable que guarda la respuesta se puede recorrer con un bucle <span class="php-res">foreach ()</span>. Cada registro obtenido en cada iteración sí tiene estrucura de matriz, en la que los índices son los nombres de las columnas:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)
$consulta  = "SELECT * FROM <i>tabla</i>";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;";
    print "    &lt;ul&gt;\n";
    foreach ($resultado as $valor) {
        print "      &lt;li&gt;$valor[<i>columna1</i>] - $valor[<i>columna2</i>] - etc.&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="basicos-desconexion">
      <h3>Desconexión con la base de datos</h3>

      <p>Para desconectar con la base de datos, simplemente hay que destruir el objeto PDO.</p>

      <div class="codigo">
        <pre><code class="language-php">$pdo = null;</code></pre>
      </div>

      <p>Aunque no se destruya el objeto PDO, PHP lo destruye al terminar la página, por lo que a menudo la instrucción no se suele escribir.</p>
    </section>
  </section>

  <section id="seguridad">
    <h2>Consultas preparadas: seguridad en las consultas</h2>

    <p>Para evitar ataques de inyección SQL (en la lección <a href="php-db-inyeccion-sql.html">Inyecciones SQL</a> se comentan los ataques más elementales), se recomienda el uso de <a href="https://www.php.net/manual/en/pdo.prepared-statements.php">sentencias preparadas</a>, en las que PDO se encarga de "desinfectar" los datos. En general, cualquier consulta que incluya datos provenientes de un formulario (o en general, provenientes del usuario de la aplicación) debe realizarse mediante consultas preparadas.</p>

    <section id="consultas-preparadas">
      <h3>Consultas preparadas</h3>

      <p>El método para efectuar consultas preparadas es primero preparar la consulta con <a href="https://www.php.net/manual/en/pdo.prepare.php"><span class="php-fun">PDO-&gt;prepare($consulta)</span></a> y después ejecutarla con <span class="php-fun"><a href="https://www.php.net/manual/en/pdostatement.execute.php">PDO-&gt;execute([parámetros])</a></span>, que devuelve el resultado de la consulta.</p>

      <div class="codigo">
        <pre>
<code class="language-php">// Consulta preparada
$consulta  = "SELECT * FROM <i>tabla</i>";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;execute();</code>
</pre>
      </div>

      <p>Si el programa incluye directamente en la consulta los datos recibidos a través de un formulario, PDO no puede hacer ninguna "desinfección" de los datos, ya que PDO no puede identificar qué parte de la consulta es la que ha llegado de un formulario y que puede haber manipulado la consulta original:</p>

      <div class="filaflex">
        <div class="icono-ok">
          <img src="../varios/iconos/icono-oksemi.svg" alt="Desaconsejado" title="Desaconsejado" width="40" height="40">
        </div>
        <div class="codigo">
          <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// ¡CUIDADO! DESACONSEJADO: PDO NO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=<i>$valor1</i></span>
             AND <span class="codigo-resaltado">columna2=<i>$valor2</i></span>";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;execute();

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>
      </div>

      <p>Para que PDO pueda desinfectar los datos provinientes de un formulario, estos deben enviarse al ejecutar la consulta, no al prepararla. Para ello, al definir la consulta es necesario indicar la posición de los datos y al ejecutar la consulta es necesario indicar el valor de los datos en forma de matriz. la posición de los datos se puede indicar de dos maneras distintas, mediante parámetros o mediante interrogantes (se aconseja la utilización de parámetros). </p>
      <ul>
        <li>consulta preparada mediante parámetros (:parametro)
          <p>En este caso las posiciones en la que se insertarán los datos provenientes del formulario se indican mediante cadenas de texto precedidas de dos puntos (:). La matriz con los datos debe incluir los nombres de los parámetros y los valores que sustituyen a los parámetros (el orden no es importante), como muestra el siguiente ejemplo:</p>

          <div class="filaflex">
            <div class="icono-ok">
              <img src="../varios/iconos/icono-oksi.svg" alt="Correcto" title="Correcto" width="40" height="40">
            </div>
            <div class="codigo">
              <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// CONSULTA PREPARADA CON PARÁMETROS: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=<i>:valor1</i></span>
             AND <span class="codigo-resaltado">columna2=<i>:valor2</i></span>";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;<span class="codigo-resaltado">execute([":valor1" =&gt; $valor1, ":valor2" =&gt; $valor2])</span>;

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
            </div>
          </div>
        </li>
        <li>consulta preparada mediantes interrogantes (?)
          <p>En este caso las posiciones en la que se insertarán los datos provenientes del formulario se indican mediante interrogantes (?). La matriz con los datos debe incluir los valores que sustituyen a los interrogantes (en el mismo orden en que aparecen en la consulta), como muestra el siguiente ejemplo:</p>

          <div class="filaflex">
            <div class="icono-ok">
              <img src="../varios/iconos/icono-oksi.svg" alt="Correcto" title="Correcto" width="40" height="40">
            </div>
            <div class="codigo">
              <pre>
<code class="language-php">$valor1 = $_REQUEST["valor1"];
$valor2 = $_REQUEST["valor2"];

// CONSULTA PREPARADA CON INTERROGANTES: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT COUNT(*) FROM <i>tabla</i>
             WHERE <span class="codigo-resaltado">columna1=?</span>
             AND <span class="codigo-resaltado">columna2=?</span>";
$resultado = $cfg-&gt;prepare($consulta);
$resultado-&gt;<span class="codigo-resaltado">execute([$valor1, $valor2])</span>;

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
            </div>
          </div>
        </li>
      </ul>

      <p><strong>Notas</strong>:</p>
      <ul>
        <li>Aunque no vayan a causar problemas en las consultas, sigue siendo conveniente tratar los datos recibidos para eliminar los espacios en blanco iniciales y finales, tratar los caracteres especiales del html, etc., como se comenta en la <a href="php-recogida-datos.html">lección de Recogida de datos</a>.</li>
        <li>La sintaxis mediante interrogantes es más cómoda, pero tiene el inconveniente de que podemos equivocarnos en el orden de los valores. Sin embargo con la sintaxis mediante parámetros, aunque sea más larga de escribir, no se puede cometer ese error.</li>
      </ul>
    </section>

    <section id="restricciones">
      <h3>Restricciones en los parámetros de consultas preparadas</h3>

      <p>Debido a que las consultas preparadas se idearon para optimizar el rendimiento de las consultas, el uso de parámetros tiene algunas restricciones. Por ejemplo</p>
      <ul>
        <li>los identificadores (nombres de tablas, nombres de columnas, etc) no pueden sustituirse por parámetros</li>
        <li>los dos elementos de una igualdad no pueden sustituirse por parámetros</li>
        <li>en general no pueden utilizarse parámetros en las consultas DDL (lenguaje de definición de datos) (nombre y tamaño de las columnas, etc.)</li>
      </ul>

      <p>Si no podemos usar parámetros, no queda más remedio que incluir los datos en la consulta. Como en ese caso PHP no hace ninguna desinfección de los datos, la desinfección la tenemos que hacer nosotros previamente.</p>

      <p>Como en estos casos los valores introducidos por el usuario suelen tener unos valores restringidos (por ejemplo, si el usuario puede elegir una columna de una tabla, los nombres de las columnas están determinadas y el usuario sólo puede elegir uno de ellos), podemos crear una función de recogida de datos específica que impida cualquier tipo de ataque de inyección por parte del usuario, como muestra el siguiente ejemplo:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// FUNCIÓN DE RECOGIDA DE UN DATO QUE SÓLO PUEDE TOMAR DETERMINADOS VALORES
function recogeValores($var, $valoresValidos, $valorPredeterminado)
{
    if (isset($_REQUEST[$var]) && in_array($_REQUEST[$nombre], $valoresValidos)) {
        return $_REQUEST[$var];
    } else {
        return $valorPredeterminado;
    }
}

// EJEMPLO DE USO DE LA FUNCIÓN ANTERIOR

// Matriz con los nombres válidos de las columnas de la tabla
$columnas = [
    "columna1",
    "columna2",
    ...
];

$columna = recogeValores("columna", $columnas, "columna1");
$valor1  = $_REQUEST["valor1"];

// CONSULTA PREPARADA CON PARÁMETROS: PDO PUEDE DESINFECTAR LOS DATOS
$consulta = "SELECT * FROM <i>tabla</i>
             WHERE columna1=<i>:valor1</i>
             ORDER BY <span class="codigo-resaltado">$columna</span> ASC";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;<span class="codigo-resaltado">execute([":valor1" =&gt; $valor1])</span>;

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    ...</code>
</pre>
      </div>
    </section>
  </section>

  <section id="ejemplos-codigo">
    <h2>Ejemplos de código</h2>

    <p>A continuación se ofrecen ejemplos de código de cómo se podría trabajar con PDO para realizar las tareas más habituales de gestión de una base de datos.</p>

    <p>La base de datos de estos ejemplos tiene una estructura muy simple: una sola tabla <i>personas</i> con tres columnas: un identificador numérico (<i>id</i>), el nombre y los apellidos de una persona.</p>

    <p>La estructura general de estas consultas se repite con ligeras variaciones. Para elegir entre unas y otras estructuras basta con fijarse en dos aspectos:</p>
    <ul>
      <li>Si el resultado de la consulta va a ser únicamente <span class="php-con">true</span> o <span class="php-con">false</span>, o si el resultado pueden ser uno o varios registros con una o varias columnas de datos. Si se pueden obtener registros, el resultado de la consulta debe guardarse en una variable auxiliar.</li>
      <li>Si en la consulta deben incluirse datos recibidos de un formulario o no. Si se incluyen datos recibidos de un formulario, es necesario utilizar consultas preparadas para prevenir ataques de inyección SQL.</li>
    </ul>


    <section id="opciones">
      <h3>Opciones del programa</h3>

      <p>Para dotar de flexibilidad a la aplicación, la aplicación incluirá opciones de configuración en forma de variables. Distinguiremos entre opciones disponibles para el administrador de la aplicación y opciones disponibles para el programador. Aunque la distinción es a veces algo arbitraria, el objetivo es ayudar al administrador de la aplicación en su puesta en marcha:</p>
      <ul>
        <li>Las opciones de administrador son las opciones que el administrador debe establecer al instalar el programa y las opciones que el programador pone a disposición del administrador para que personalice la aplicación.</li>
        <li>Las opciones de programador son las opciones que el administrador no necesita modificar para instalar el programa, pero que el programador ha preparado para dar mayor flexibilidad a la aplicación. Por supuesto, el administrador puede modificarlas si entiende las consecuencias que podría provocar su modificación.</li>
      </ul>

      <p>Estas podrían ser las opciones para <strong>SQLite</strong>:</p>

      <div class="codigo">
        <pre>
<code class="copy-language-php">// SQLITE: OPCIONES DE CONFIGURACIÓN DEL PROGRAMA

// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN
// Configuración para SQLite
$cfg["sqliteDatabase"] = "tmp.sqlite";                            // Ubicación de la base de datos

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN
// Base de datos
$cfg["dbPersonasTabla"]        = "personas";                      // Nombre de la tabla Personas
$cfg["dbPersonasTamNombre"]    = 40;                              // Tamaño de la columna Personas &gt; Nombre
$cfg["dbPersonasTamApellidos"] = 60;                              // Tamaño de la columna Personas &gt; Apellidos</code>
</pre>
      </div>

      <p>Estas podrían ser las opciones para <strong>MySQL</strong>:</p>

      <div class="codigo">
        <pre>
<code class="copy-language-php">// MYSQL: OPCIONES DE CONFIGURACIÓN DEL PROGRAMA

// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN
// Configuración para MySQL
$cfg["mysqlHost"]     = "mysql:host=localhost";                   // Nombre de host
$cfg["mysqlUser"]     = "";                                       // Nombre de usuario
$cfg["mysqlPassword"] = "";                                       // Contraseña de usuario
$cfg["mysqlDatabase"] = "";                                       // Nombre de la base de datos

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN
// Base de datos
$cfg["dbPersonasTabla"]        = "$cfg[mysqlDatabase].personas";  // Nombre de la tabla Personas
$cfg["dbPersonasTamNombre"]    = 40;                              // Tamaño de la columna Personas &gt; Nombre
$cfg["dbPersonasTamApellidos"] = 60;                              // Tamaño de la columna Personas &gt; Apellidos</code>
</pre>
      </div>
    </section>

    <section id="conexion">
      <h3>Conexión con la base de datos</h3>

      <p>Para conectar con la base de datos hay que crear una instancia de la clase PDO, que se utiliza en todas las consultas posteriores. En cada página php que incluya consultas a la base de datos es necesario conectar primero con la base de datos.</p>

      <p>Si no se puede establecer la conexión con la base de datos, puede deberse a que la base de datos no esté funcionando, a que los datos de usuario no sean correctos, a que no esté activada la extensión pdo o (en el caso de SQLite) que el camino donde se quiere guardar la base de datos no exista.</p>

      <section id="conexion-sqlite">
        <h4>Conexión con SQLite 3</h4>

        <p>En SQLite, no se hace una conexión a un servidor, sino que simplemente se indica el archivo que va a contener la base de datos. En SQLite no hay un servidor que gestiona todas las bases de datos, sino que cada base de datos es un archivo independiente (que debe estar situado en un directorio que exista y en el que el servidor web tenga permisos de escritura).</p>

        <p>Para poder utilizar SQLite mediante PDO, debe estar activada la extensión pdo_sqlite en el archivo de configuración php.ini (véase el <a href="../otros/php-configuracion-1.html#pdo-sqlite">apartado extensión pdo_sqlite en la lección de configuración de Apache y PHP</a>).</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// SQLITE: CONEXIÓN CON LA BASE DE DATOS
function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("sqlite:$cfg[sqliteDatabase]");
        $tmp-&gt;query("PRAGMA foreign_keys = ON");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos / {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}

// CONEXIÓN CON LA BASE DE DATOS
// La conexión se debe realizar en cada página que acceda a la base de datos
$pdo = conectaDb();</code>
</pre>
        </div>

        <p><strong>Notas</strong>:</p>
        <ul>
          <li>En las soluciones de los ejercicios proporcionadas en estos apuntes, los archivos se guardan en el directorio <strong>/home/barto/mclibre/tmp/mclibre/</strong>. Para que funcionen las soluciones, se debe crear ese directorio o cambiarlo a otro.</li>
          <li>En caso de error, la función conectaDb() imprime unos mensajes de error y termina el programa. Si quisieramos completar una página correcta, deberíamos imprimir el pie de página en caso de error y asegurarnos de que se ha escrito la cabecera antes de conectarse a la base de datos.</li>
        </ul>
      </section>

      <section id="conexion-mysql">
        <h4>Conexión con MySQL</h4>

        <p>En el caso de MySQL, para crear el objeto PDO se necesita proporcionar el nombre del servidor, el nombre de usuario y la contraseña. En el ejemplo siguiente esos datos se proporcionan como constantes que deberían definirse en el programa.</p>

        <p>Para poder acceder a MySQL mediante PDO, debe estar activada la extensión php_pdo_mysql en el archivo de configuración php.ini (véase el <a href="../otros/php-configuracion-1.html#pdo-mysql">apartado extensión pdo_mysql en la lección de configuración de Apache y PHP</a>).</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// MYSQL: CONEXIÓN CON LA BASE DE DATOS
function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO($cfg["mysqlHost"], $cfg["mysqlUser"], $cfg["mysqlPassword"]);
        $tmp-&gt;setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
        $tmp-&gt;exec("set names utf8mb4");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos / {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}

// EJEMPLO DE USO DE LA FUNCIÓN conectaDb()
// La conexión se debe realizar en cada página que acceda a la base de datos
$pdo = conectaDb();</code>
</pre>
        </div>
      </section>
    </section>

    <section id="create-drop">
      <h3>Creación y borrado de bases de datos y tablas: Consultas CREATE DATABASE, DROP DATABASE, CREATE TABLE, DROP TABLE</h3>

      <p>Las consultas de creación no son iguales en MySQL y SQLite. Para que una misma aplicación pueda trabajar con una u otra base de datos, en el apartado <a href="#configurable">aplicación configurable</a> estas consultas se incluyen en bibliotecas específicas.</p>
      <ul>
        <li>Las consultas de creación de bases de datos CREATE DATABASE suelen ser específicas de cada base de datos. En el caso de utilizar SQLite, en realidad no tiene sentido crear o borrar la base de datos ya que con SQLite cada base de datos es un fichero distinto y al conectar con la base de datos ya se dice con qué archivo se va a trabajar y se crea en caso necesario.</li>
        <li>Las consultas de creación de tablas CREATE TABLE suelen ser específicas de cada base de datos. Los ejemplos de este apartado no utilizan sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</li>
      </ul>

      <section id="create-sqlite">
        <h4>Creación y borrado de tablas en SQLite</h4>

        <p>En el caso de utilizar SQLite, no tiene sentido crear o borrar la base de datos ya que SQLite trabaja con ficheros y cada fichero es una base de datos. Tan solo es necesario borrar y crear las tablas.</p>

        <p>Para borrar una tabla, se utiliza la consulta DROP TABLE. Esta consulta no es específica de SQlite pero se comenta en este apartado por estar relacionada con las demás consultas de este apartado. Se ha añadido la condición IF EXISTS porque en algunas versiones de SQLite la consulta DROP TABLE da error si la tabla no existe.</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// CONSULTA DE BORRADO DE TABLA
$consulta = "DROP TABLE IF EXISTS $cfg[dbPersonasTabla]";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al borrar la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Tabla borrada correctamente (si existía).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>

        <p>Para crear una tabla, se utiliza la consulta CREATE TABLE. Las consultas de creación de tabla suelen ser específicas de cada base de datos. El ejemplo no utiliza sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// SQLITE: CONSULTA DE CREACIÓN DE TABLA
$consulta = "CREATE TABLE $cfg[dbPersonasTabla]  (
             id INTEGER PRIMARY KEY,
             nombre VARCHAR($cfg[dbPersonasTamNombre]),
             apellidos VARCHAR($cfg[dbPersonasTamApellidos])
             )";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>
      </section>

      <section id="create-mysql">
        <h4>Creación y borrado de bases de datos y tablas en MySQL</h4>

        <p>Para borrar una base de datos, se utiliza la consulta DROP DATABASE. Se ha añadido la condición IF EXISTS porque en algunas bases de datos la consulta DROP DATABASE da error si la tabla no existe.</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// MYSQL: CONSULTA DE BORRADO DE BASE DE DATOS
$consulta = "DROP DATABASE IF EXISTS $cfg[mysqlDatabase]";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al borrar la base de datos / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Base de datos borrada correctamente (si existía).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>

        <p>Para crear una base de datos, se utiliza la consulta CREATE DATABASE.</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// MYSQL: CONSULTA DE CREACIÓN DE BASE DE DATOS
$consulta = "CREATE DATABASE $cfg[mysqlDatabase]
             CHARACTER SET utf8mb4
             COLLATE utf8mb4_unicode_ci";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la base de datos / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Base de datos creada correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>

        <p><strong>Nota</strong>: El juego de caracteres utilizado en este curso es <strong>UTF-8</strong>, por lo que en la base de datos MySQL se utiliza el juego de caracteres <strong>utf8mb4</strong> (que permite almacenar cualquier carácter Unicode) y el cotejamiento <strong>utf8mb4_unicode_ci</strong> (que implementa todos los criterios de ordenación de Unicode). Para una explicación más detallada se puede consultar <a href="https://mathiasbynens.be/notes/mysql-utf8mb4">el blog de Mathias Bynens</a>.</p>

        <p>Para borrar una tabla, se utiliza la consulta DROP TABLE. Esta consulta no es específica de MySQL pero se comenta en este apartado por estar relacionada con las demás consultas de este apartado. Se ha añadido la condición IF EXISTS porque en algunas bases de datos la consulta DROP TABLE da error si la tabla no existe.</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// CONSULTA DE BORRADO DE TABLA
$consulta = "DROP TABLE IF EXISTS $cfg[dbPersonasTabla]";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al borrar la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Tabla borrada correctamente (si existía).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>

        <p>Para crear una tabla, se utiliza la consulta CREATE TABLE. Las consultas de creación de tabla suelen ser específicas de cada base de datos. El ejemplo no utiliza sentencias preparadas (en caso de utilizarse sentencias preparadas, las variables no podrían ir como parámetros por tratarse de sentencias DDL).</p>

        <div class="codigo">
          <pre>
<code class="copy-language-php">// MYSQL: CONSULTA DE CREACIÓN DE TABLA
$consulta = "CREATE TABLE $cfg[dbPersonasTabla]  (
             id INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
             nombre VARCHAR($cfg[dbPersonasTamNombre]),
             apellidos VARCHAR($cfg[dbPersonasTamApellidos]),
             PRIMARY KEY(id)
             )";

if (!$pdo-&gt;query($consulta)) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
        </div>
      </section>
    </section>

    <section id="insert-update-delete">
      <h3>Creación, actualización y borrado de registros: Consultas INSERT INTO, UPDATE, DELETE FROM</h3>

      <p>Estas consultas son iguales en MySQL y SQLite.</p>

      <ul>
        <li>Para añadir un registro a una tabla, se utiliza la consulta INSERT INTO.

          <div class="codigo">
            <pre>
<code class="copy-language-php">// CONSULTA DE INSERCIÓN DE REGISTRO
$nombre    = "Pepito";            // Normalmente estos valores vendrán de un formulario
$apellidos = "Conejo";

$consulta = "INSERT INTO $cfg[dbPersonasTabla]
             (nombre, apellidos)
             VALUES (:nombre, :apellidos)";
$resultado = $pdo-&gt;prepare($consulta);

if (!$resultado-&gt;execute([":nombre" =&gt; $nombre, ":apellidos" =&gt; $apellidos])) {
    print "    &lt;p class=\"aviso\"&gt;Error al crear el registro / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Registro creado correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
        <li>Para modificar un registro a una tabla, se utiliza la consulta UPDATE.

          <div class="codigo">
            <pre>
<code class="copy-language-php">// CONSULTA DE MODIFICACIÓN DE REGISTRO
$id        = "1";                 // Normalmente estos valores vendrán de un formulario
$nombre    = "Pepita";
$apellidos = "Conejo";

$consulta = "UPDATE $cfg[dbPersonasTabla]
             SET nombre=:nombre, apellidos=:apellidos
             WHERE id=:id";
$resultado = $pdo-&gt;prepare($consulta);

if (!$resultado-&gt;execute([":nombre" =&gt; $nombre, ":apellidos" =&gt; $apellidos, ":id" =&gt; $id])) {
    print "    &lt;p class=\"aviso\"&gt;Error al modificar el registro / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Registro modificado correctamente.&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Para borrar un registro de una tabla, se utiliza la consulta DELETE FROM.

          <p><strong>Nota</strong>: En el ejemplo, los registros a borrar se reciben en forma de matriz y se recorre la matriz borrando un elemento en cada iteración.</p>

          <div class="codigo">
            <pre>
<code class="copy-language-php">// CONSULTA DE BORRADO DE REGISTROS
$id = [1 =&gt; "on"];     // Normalmente este valor vendrá de un formulario
                       // en forma de matriz. Por ejemplo, [1 =&gt; "on", 3 =&gt; "on"]

foreach ($id as $indice =&gt; $valor) {
    $consulta = "DELETE FROM $cfg[dbPersonasTabla]
                 WHERE id=:indice";
    $resultado = $pdo-&gt;prepare($consulta);

    if (!$resultado-&gt;execute([":indice" =&gt; $indice])) {
        print "    &lt;p class=\"aviso\"&gt;Error al borrar el registro / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
        print "\n";
    } else {
        print "    &lt;p&gt;Registro borrado correctamente.&lt;/p&gt;\n";
        print "\n";
    }
}</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="select">
      <h3>Selección de registros: Consulta SELECT</h3>

      <p>Para obtener registros que cumplan determinados criterios se utiliza una consulta SELECT. Estas consultas son iguales en MySQL y SQLite.</p>
      <ul>
        <li>Si la consulta devuelve un único registro con una sola columna se puede utilizar la función <a href="https://www.php.net/manual/en/pdostatement.fetchcolumn.php">PDOStatement-&gt;fetchColumn()</a> para recuperar el dato.

          <div class="codigo">
            <pre>
<code class="copy-language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA
$consulta = "SELECT COUNT(*) FROM $cfg[dbPersonasTabla]";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;La tabla contiene {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve un único registro, se puede utilizar la función <a href="https://www.php.net/manual/en/pdostatement.fetch.php">PDOStatement-&gt;fetch()</a> para recuperar el registro en forma de matriz. De forma predeterminada, los valores del registro aparecen repetidos en la matriz y para acceder a los valores se puede utilizar como índice tanto los nombres de las columnas de la tabla como números enteros correlativos (0, 1, 2, etc.). Si se envía como argumento la constante PDO::FETCH_ASSOC, los índices de la matriz son únicamente los nombres de las columnas de la tabla.
          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO (O NINGUNO)
$id = 1       // Normalmente este valor vendrá de un formulario

$consulta  = "SELECT * FROM <i>tabla</i> WHERE id=:id";
$resultado = $pdo-&gt;prepare($consulta);
$resultado -&gt;execute([":id" = &gt; $id);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    $valor = $resultado-&gt;fetch();
    print "    &lt;p&gt;&lt;strong&gt;Registro obtenido&lt;/strong&gt;&lt;/p&gt;";
    print "\n";
    print "    &lt;p&gt;$valor[id] - $valor[nombre] - $valor[apellidos].&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>

        <li>Si la consulta devuelve varios registros (es decir, que la consulta puede potencialmente devolver varios registros, aunque igual no devuelve ninguno, o devuelve sólo uno, dependiendo de la consulta concreta y de los registros guardados), para acceder a los registros devueltos por la consulta ...

          <ul>
            <li>Habitualmente se utiliza un bucle <span class="php-res">foreach</span> para recorrer todos los registros devueltos. Es importante tener en cuenta que sólo se puede iterar una vez sobre el resultado de la consulta, ya que los registros se van eliminado del resultado de la consulta.

              <div class="codigo">
                <pre>
<code class="copy-language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)
$consulta = "SELECT * FROM $cfg[dbPersonasTabla]";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;";
    print "    &lt;ul&gt;\n";
    foreach ($resultado as $valor) {
        print "      &lt;li&gt;$valor[id] - $valor[nombre] - $valor[apellidos]&lt;/li&gt;\n";
    }
    print "    &lt;/ul&gt;\n";
}</code>
</pre>
              </div>
            </li>
            <li>pero también se puede utilizar un bucle <span class="php-res">while</span> y la función <a href="https://www.php.net/manual/en/pdostatement.fetch.php"><span class="php-fun">PDOStatement-&gt;fetch()</span></a>, que recupera el primer registro de la consulta. Es importante tener en cuenta que sólo se puede iterar una vez sobre el resultado de la consulta, ya que los registros se van eliminado del resultado de la consulta.
              <div class="codigo">
                <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)
$consulta = "SELECT * FROM $cfg[dbPersonasTabla]";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta {$pdo-&gt;errorInfo()[2]}.&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;";
    print "    &lt;ul&gt;\n";
    while ($valor = $resultado-&gt;fetch()) {
        print "      &lt;li&gt;$valor[id] - $valor[nombre] - $valor[apellidos]&lt;/li&gt;\n";
        print "\n";
    }
    print "    &lt;/ul&gt;\n";
}</code>
</pre>
              </div>
            </li>

            <li>Los dos ejemplos anteriores (con <span class="php-res">foreach</span> o <span class="php-fun">fetch()</span>) no tratarían de forma adecuada el caso en el que la consulta no devolviera ningún registro, ya que no escribirían nada. Por ello se recomienda hacer primero una consulta que cuente el número de resultados de la consulta y, si es mayor que cero, hacer la consulta que recupera los registros.

              <div class="codigo">
                <pre>
<code class="copy-language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE PUEDE DEVOLVER VARIOS REGISTROS (O UNO O NINGUNO)
$consulta = "SELECT COUNT(*) FROM $cfg[dbPersonasTabla]";
$resultado = $pdo-&gt;query($consulta);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta {$pdo-&gt;errorInfo()[2]}.&lt;/p&gt;\n";
    print "\n";
} elseif ($resultado-&gt;fetchColumn() == 0) {
    print "    &lt;p&gt;No se ha creado todavía ningún registro en la tabla.&lt;/p&gt;\n";
    print "\n";
} else {
    $consulta = "SELECT * FROM $cfg[dbPersonasTabla]";
    $resultado = $pdo-&gt;query($consulta);

    if (!$resultado) {
        print "    &lt;p class=\"aviso\"&gt;Error en la consulta {$pdo-&gt;errorInfo()[2]}.&lt;/p&gt;\n";
        print "\n";
    } else {
        print "    &lt;p&gt;&lt;strong&gt;Registro(s) obtenido(s)&lt;/strong&gt;&lt;/p&gt;";
        print "    &lt;ul&gt;\n";
        foreach ($resultado as $valor) {
            print "      &lt;li&gt;$valor[id] - $valor[nombre] - $valor[apellidos]&lt;/li&gt;\n";
        }
        print "    &lt;/ul&gt;\n";
    }
}</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ul>
    </section>

    <section id="select-like">
      <h3>Selección de registros: Consulta SELECT LIKE</h3>

      <p>La consulta SELECT permite efectuar búsquedas en cadenas utilizando el condicional LIKE o NOT LIKE y los comodines _ (cualquier carácter) o % (cualquier número de caracteres). Estas consultas son iguales en MySQL y SQLite.</p>

      <p>Ejemplos de consultas:</p>
      <ul>
        <li>Registros en los que el apellido empieza por la cadena recibida:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA
$apellidos = "Con";           // Normalmente este valor vendrá de un formulario

$consulta = "SELECT COUNT(*) FROM $cfg[dbPersonasTabla]
             WHERE apellidos LIKE :apellidos";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;execute([":apellidos" =&gt; "<span class="codigo-resaltado">$apellidos%</span>"]);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
        <li>Registros en los que el apellido contiene la cadena recibida:

          <div class="codigo">
            <pre>
<code class="language-php">// CONSULTA DE SELECCIÓN DE REGISTROS QUE DEVUELVE UN ÚNICO REGISTRO DE UNA COLUMNA
$apellidos = "nej";           // Normalmente este valor vendrá de un formulario

$consulta = "SELECT COUNT(*) FROM $cfg[dbPersonasTabla]
             WHERE apellidos LIKE :apellidos";
$resultado = $pdo-&gt;prepare($consulta);
$resultado-&gt;execute([":apellidos" =&gt; "<span class="codigo-resaltado">%$apellidos%</span>"]);

if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
    print "    &lt;p&gt;Se han encontrado {$resultado-&gt;fetchColumn()} registro(s).&lt;/p&gt;\n";
    print "\n";
}</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="union-tablas">
      <h3>Consultas de unión de tablas</h3>

      <p>Se pueden también realizar consultas de unión entre varias tablas, como en el ejemplo siguiente. El ejemplo está sacado del <a href="../ejercicios/bases-de-datos-viejos/biblioteca-1.html">ejercicio de Biblioteca</a>) y devuelve los préstamos pendientes de devolver a partir de tres tablas de Usuarios, Obras y Préstamos:</p>

      <div class="codigo">
        <pre>
<code class="language-php">// CONSULTA DE UNIÓN DE TABLAS
$consulta = "SELECT
               $cfg[dbTablaPrestamos].id AS id,
               $cfg[dbTablaUsuarios].nombre as nombre,
               $cfg[dbTablaUsuarios].apellidos as apellidos,
               $cfg[dbTablaObras].titulo as titulo,
               $cfg[dbTablaPrestamos].prestado as prestado,
               $cfg[dbTablaPrestamos].devuelto as devuelto
             FROM $cfg[dbTablaPrestamos], $cfg[dbTablaUsuarios], $cfg[dbTablaObras]
             WHERE
               $cfg[dbTablaPrestamos].id_usuario=$cfg[dbTablaUsuarios].id
               AND $cfg[dbTablaPrestamos].id_obra=$$cfg[dbTablaObras].id
               AND $cfg[dbTablaPrestamos].devuelto='0000-00-00'
             ORDER BY $columna $orden";
$resultado = $pdo-&gt;query($consulta);
if (!$resultado) {
    print "    &lt;p class=\"aviso\"&gt;Error en la consulta / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    print "\n";
} else {
   ...</code>
</pre>
      </div>
    </section>
  </section>

  <section id="configurable">
    <h2>Aplicación configurable</h2>

    <p>En los ejercicios en este curso se propone al alumno organizar los programas de manera que puedan trabajar tanto con SQLite como con MySQL y hacerlo de forma organizada, para que se puedan añadir fácilmente otras bases de datos.</p>

    <p>Para ello distribuiremos los elementos comunes (constantes, variables y funciones) en cuatro ficheros distintos</p>
    <ul>
      <li>config.php. En este fichero escribiremos las opciones de configuración a disposición del usuario.</li>
      <li>biblioteca.php. En este fichero escribiremos los elementos comunes que no dependen de la base de datos utilizada.</li>
      <li>biblioteca-sqlite.php. En este fichero escribiremos los elementos comunes que necesitan adaptarse para utilizar SQLite.</li>
      <li>biblioteca-mysql.php. En este fichero escribiremos los elementos comunes que necesitan adaptarse para utilizar MySQL.</li>
    </ul>

    <p>Todas las páginas de la aplicación cargarán la biblioteca general, que a su vez cargará el fichero de configuración y una de las dos bibliotecas específicas, de acuerdo con la configuración escogida por el usuario.</p>

    <section id="conexion-configurable">
      <h3>Conexión configurable</h3>

      <p>Por ejemplo, para el caso de la función de conexión, el resultado sería:</p>
      <ul>
        <li>config.php: en este fichero se especifica la base de datos que se va a utilizar:

          <div class="codigo">
            <pre>
<code class="language-php">// config.php

// OPCIONES DISPONIBLES PARA EL ADMINISTRADOR DE LA APLICACIÓN
// Base de datos utilizada por la aplicación
<span class="codigo-resaltado">$cfg["dbMotor"]</span> = SQLITE;                                     // Valores posibles: MYSQL o SQLITE

// Configuración para SQLite
$cfg["sqliteDatabase"] = "tmp.sqlite";                        // Ubicación de la base de datos

// Configuración para MySQL
$cfg["mysqlHost"]     = "mysql:host=localhost";               // Nombre de host
$cfg["mysqlUser"]     = "";                                   // Nombre de usuario
$cfg["mysqlPassword"] = "";                                   // Contraseña de usuario
$cfg["mysqlDatabase"] = "";                                   // Nombre de la base de datos</code>
</pre>
          </div>
        </li>
        <li>biblioteca.php: la configuración establecida en config.php determina la biblioteca específica a cargar:

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca.php

// CONSTANTES
define("SQLITE", 1);
define("MYSQL", 2);

require_once "config.php";

if ($cfg["dbMotor"] == SQLITE) {
    require_once "biblioteca-sqlite.php";
} elseif ($cfg["dbMotor"] == MYSQL) {
    require_once "biblioteca-mysql.php";
}</code>
</pre>
          </div>
        <li>biblioteca-sqlite.php: contiene la definición de la función conectaDb() específica para trabajar con SQLite

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-sqlite.php

// SQLITE: CONEXIÓN CON LA BASE DE DATOS
function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO("sqlite:$cfg[sqliteDatabase]");
        $tmp-&gt;query("PRAGMA foreign_keys = ON");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos / {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}</code>
  </pre>
          </div>
        </li>
        </li>
        <li>biblioteca-mysql.php: contiene la definición de la función conectaDb() específica para trabajar con MySQL

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-mysql.php

// MYSQL: CONEXIÓN CON LA BASE DE DATOS
function conectaDb()
{
    global $cfg;

    try {
        $tmp = new PDO($cfg["mysqlHost"], $cfg["mysqlUser"], $cfg["mysqlPassword"]);
        $tmp-&gt;setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);
        $tmp-&gt;exec("set names utf8mb4");
        return $tmp;
    } catch (PDOException $e) {
        print "    &lt;p class=\"aviso\"&gt;Error: No puede conectarse con la base de datos / {$e-&gt;getMessage()}&lt;/p&gt;\n";
        exit;
    }
}</code>
</pre>
          </div>
        </li>
        <li>finalmente, en cualquier fichero que quiera conectar con la base de datos se llamaría a la biblioteca general y se llamaría a la función genérica conectaDb():

          <div class="codigo">
            <pre>
<code class="language-php">// EJEMPLO DE USO DE CONEXIÓN CONFIGURABLE
// La conexión se debe realizar en cada página que acceda a la base de datos
require_once "biblioteca.php";
$pdo = conectaDb();</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="create-drop-configurable">
      <h4>Borrado y creación de base de datos y tablas configurable</h4>

      <p>El resultado sería</p>
      <ul>
        <li>biblioteca.php: contiene las variables de configuración del programador comunes:

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca.php

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN
// Base de datos
$cfg["dbPersonasTamNombre"]    = 40;                 // Tamaño de la columna Personas &gt; Nombre
$cfg["dbPersonasTamApellidos"] = 60;                 // Tamaño de la columna Personas &gt; Apellidos</code>
</pre>
          </div>
        </li>
        <li>biblioteca-sqlite.php: contiene las variables de configuración del programador específicas de SQLite y la definición de la función borraTodo() específica para trabajar con SQLite:

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-sqlite.php

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN
// Base de datos
$cfg["dbPersonasTabla"]        = "personas";         // Nombre de la tabla Personas

// SQLITE: CONSULTAS DE BORRADO Y CREACiÓN DE TABLA
function borraTodo()
{
    global $pdo, $cfg;

    $consulta = "DROP TABLE IF EXISTS $cfg[dbPersonasTabla]";
    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al borrar la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Tabla borrada correctamente (si existía).&lt;/p&gt;\n";
    }
    print "\n";

    $consulta = "CREATE TABLE $cfg[dbPersonasTabla]  (
                 id INTEGER PRIMARY KEY,
                 nombre VARCHAR($cfg[dbPersonasTamNombre]),
                 apellidos VARCHAR($cfg[dbPersonasTamApellidos])
                 )";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
    }
}</code>
</pre>
          </div>
        </li>
        <li>biblioteca-mysql.php: contiene las variables de configuración del programador específicas de MySQL y la definición de la función borraTodo() específica para trabajar con MySQL

          <div class="codigo">
            <pre>
<code class="language-php">// biblioteca-mysql.php

// OPCIONES DISPONIBLES PARA EL PROGRAMADOR DE LA APLICACIÓN
// Base de datos
$cfg["dbPersonasTabla"] = "$cfg[mysqlDatabase].personas";   // Nombre de la tabla Personas

// MYSQL: CONSULTAS DE BORRADO Y CREACiÓN DE BASE DE DATOS Y TABLA
function borraTodo()
{
    global $pdo, $cfg;

    $consulta = "DROP DATABASE IF EXISTS $cfg[mysqlDatabase]";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al borrar la base de datos / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Base de datos borrada correctamente (si existía).&lt;/p&gt;\n";
    }
    print "\n";

    $consulta = "CREATE DATABASE $cfg[mysqlDatabase]
                 CHARACTER SET utf8mb4
                 COLLATE utf8mb4_unicode_ci";

    if (!$pdo-&gt;query($consulta)) {
        print "    &lt;p class=\"aviso\"&gt;Error al crear la base de datos / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
    } else {
        print "    &lt;p&gt;Base de datos creada correctamente.&lt;/p&gt;\n";
        print "\n";
        $consulta = "CREATE TABLE $cfg[dbPersonasTabla]  (
                     id INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
                     nombre VARCHAR($cfg[dbPersonasTamNombre]),
                     apellidos VARCHAR($cfg[dbPersonasTamApellidos]),
                     PRIMARY KEY(id)
                     )";

        if (!$pdo-&gt;query($consulta)) {
            print "    &lt;p class=\"aviso\"&gt;Error al crear la tabla / {$pdo-&gt;errorInfo()[2]}&lt;/p&gt;\n";
        } else {
            print "    &lt;p&gt;Tabla creada correctamente.&lt;/p&gt;\n";
        }
    }
}</code>
</pre>
          </div>
        </li>
        <li>finalmente, en el fichero que quiera reiniciar la base de datos se llamaría a la biblioteca general y se llamaría a la función genérica borraTodo():

          <div class="codigo">
            <pre>
<code class="language-php">// EJEMPLO DE USO DE BORRADO CONFIGURABLE
require_once "biblioteca.php";
$pdo = conectaDb();
borraTodo();
$pdo = null;</code>
</pre>
          </div>
        </li>
      </ul>
    </section>
  </section>

  <footer>
    <p class="ultmod">Última modificación de esta página: 29 de diciembre de 2021</p>

    <p class="licencia">
      <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES"><img src="../varios/iconos/icono-cc-by-sa.svg" alt="Licencia Creative Commons" title="Licencia Creative Commons BY-SA" width="120" height="42"></a><br>
      Esta página forma parte del curso <strong><a href="https://www.mclibre.org/consultar/php/">Programación web en PHP</a></strong> por <a href="https://www.mclibre.org/" rel="author">Bartolomé Sintes Marco</a><br>
      que se distribuye bajo una <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES">Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)</a>.
    </p>
  </footer>
</body>
</html>
